# Functions, Big and Small

```agda
module functions where
```

Computer science is chocked full of data structures. A great many come from the
official pantheon---things like binary search trees, hash maps, stacks, graphs,
and heaps. But, dwarfing all of these, there exists orders of magnitude more
data structures in the arcane vault, from the
passingly-familiar-but-unlikely-to-have-implemented *rope* to the obscure *Judy
array.* With so many options to choose from, how can we even hope to make an
informed choice?

The reason there exist many more data structures than any practitioner can
possibly know about is that most data structures are minor tweaks of other
well-known structures. For example, the UB-tree is a variation on the B+ tree,
which itself is a B-tree that maintains a particular invariant, while a B-tree
is a generalization of the binary search tree (BST henceforth). Unrolling the
lineage here shows us that whatever the UB-tree is, it's probably a BST that has
more desirable computational properties for certain shapes of data.

As Donald Knuth said, "premature optimization is the root of all evil." For the
vast majority of tasks, you can start with (and subsequently get away with) a
BST, upgrading to the more complex UB-tree in the future only if it turns out to
be mission critical. This is a well-understood idea in the modern age.

However, most programmers coming to Agda make an error in the spirit of the
Co-Blub paradox. After years of honing their taste and cutting their teeth on
picking the simplest data structure for the job, they come to Agda and
immediately fall down the rabbit-hole of long, arduous proofs. As I have gotten
older and more experienced, my guiding philosophy for writing software has
become *if it feels too hard, it probably is.*

As it happens, your choice of representation matters much more in Agda than it
does in most programming languages. That arises from the fact that your proofs
will inevitably trace the same grooves as the implementations they are proofs
*about.* In other words, the proof follows the implementation. It's not hard to
imagine that a complicated implementation will warrant a complicated proof.


## Matrices

Let's work through an example together, to get a feel for just how important a
representation can be. Our object of investigation will be *matrices*---that is,
rectangular arrays of numbers. Matrices are often used in computational
geometry, including 3D graphics, and are the back-bone of modern machine
learning techniques. As an exercise in honing our
translating-mathematics-to-Agda chops, let's take a look at the definition of a
matrix.

Matrix
:   A rectangular array of numbers.

Matrices have a predefined height and width, often referred to as $m$ and $n$
respectively, and given in that order. For example, the following is a 3x2
matrix:

```text
1   1
5  -42
0  2.5
```

Note that the numbers inside a matrix are rather flexible. Depending on the
circumstances, we might prefer them to be naturals, while in others we might
want reals, or even functions. In order to avoid the complexities here, we will
simply parameterize the our module over the type of numbers, and postulate any
properties of those numbers as the need occurs. Let's call this number type
parameter `ùî∏`:

```agda
module matrix-induction {ùî∏ : Set} where
```


### The Row-Major Representation

Returning to the problem of modeling matrices in Agda, note that we don't have
any good, inductive primitives for two-dimensional data, I think most
programmers would thus come up with the next best thing: the "vector of vectors"
model---indeed, it's what I first thought of.

```agda
  open import Data.Product
    as Œ£
    using (_√ó_; _,_)
  open import Data.Nat
    using (‚Ñï; zero; suc)
  open import Data.Vec
    using (Vec; []; _‚à∑_)

  Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
  Matrix m n = Vec (Vec ùî∏ n) m

  private variable
    m n p : ‚Ñï
```

This representation is known as the "row-major order" of matrices, that is, the
rows have contiguous data, while the columns do not. There are immediate
repercussions here. For example, let's implement the function `top/rest` which
separates the first row from the rest of the matrix:

```agda
  top/rest
      : Matrix (suc m) n
      ‚Üí Vec ùî∏ n √ó Matrix m n
  top/rest (x ‚à∑ xs) = x , xs
```

Compare `top/rest` to the analogous function that pulls the leftmost column off
of a matrix:

```agda
  left/rest
      : Matrix m (suc n)
      ‚Üí Vec ùî∏ m √ó Matrix m n
  left/rest [] = [] , []
  left/rest ((x ‚à∑ v) ‚à∑ m)
    = Œ£.map (x ‚à∑_) (v ‚à∑_) (left/rest m)
```

The dramatic difference in complexity between these two analogous functions is
telling. Clearly, row-major order significantly privileges working with rows
over working with columns.

Nevertheless, we can continue by implementing a few special matrices of note.
First is the zero-matrix, which is the matrix that is full only of zeroes. Note
that we will also need to postulate the existence of `0# : ùî∏`.

```agda
  postulate 0# : ùî∏

  open Data.Vec
    using (replicate)

  0‚Çò : Matrix m n
  0‚Çò = replicate (replicate 0#)
```

Two matrices of the same dimensions support a kind of addition, given by adding
the respective cells in each of the two columns. That is:

$$
\begin{bmatrix}
a & b & c\\
d & e & f
\end{bmatrix}
+
\begin{bmatrix}
x & y & z\\
t & u & v
\end{bmatrix}
=
\begin{bmatrix}
a + x & b + y & c + z\\
d + t & e + u & f + v
\end{bmatrix}
$$

We can implement this operation over matrices by positing the existence of an
addition over `ùî∏`, as well as some common-sense identity laws:

```agda
  open import Relation.Binary.PropositionalEquality

  postulate
    _+_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏
    +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x
    +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x

  open Data.Vec
    using (zipWith)
```

Addition of matrices doesn't present us any problems, as pointwise operations
don't need to distinguish between rows and columns. Thus, we can zip the rows
together, zip the corresponding cells together, and add each pair:

```agda
  _+‚Çò_ : Matrix m n ‚Üí Matrix m n ‚Üí Matrix m n
  x +‚Çò y = zipWith (zipWith _+_) x y
```

Let's now prove the trivial fact that `0‚Çò` is a left identity for `+‚Çò`:

```agda
  +‚Çò-identityÀ° : (x : Matrix m n) ‚Üí 0‚Çò +‚Çò x ‚â° x
```

We can begin, as always, with induction on our argument. The first case, in
which `m ‚â° 0`, is easy:

```agda
  +‚Çò-identityÀ° [] = refl
```

The case that `n ‚â° 0` is also easy, although slightly more work, as our
row-major order would suggest:

```agda
  +‚Çò-identityÀ° ([] ‚à∑ rs)
    rewrite +‚Çò-identityÀ° rs
      = refl
```

We're now left with the induction case. After some obvious rewriting to
eliminate the `0# +_` and the row-recursive case, we're left here:

```agda
  +‚Çò-identityÀ° ((c ‚à∑ cs) ‚à∑ rs)
    rewrite +-identityÀ° c
    rewrite +‚Çò-identityÀ° rs
```

with the goal

```goal
  (c ‚à∑ zipWith _+_ (replicate 0#) cs) ‚à∑ rs
‚â°
  (c ‚à∑ cs) ‚à∑ rs
```

and it's unclear how to move forwards. It would be nice if our induction just
worked, but, unfortunately, it doesn't. Crossing our fingers that this is not a
serious problem, we can write a little lemma to solve the goal for us:

```agda
      = cong (Œª œÜ ‚Üí (c ‚à∑ œÜ) ‚à∑ rs) (lemma cs)

    where
      lemma
          : ‚àÄ {m} (cs : Vec ùî∏ m)
          ‚Üí zipWith _+_ (replicate 0#) cs ‚â° cs
      lemma [] = refl
      lemma (c ‚à∑ cs)
        rewrite +-identityÀ° c
        rewrite lemma cs
          = refl
```

It's not the tidiest proof in the world, but it certainly gets the job done.
However, we should be wary here; this is our second function in which dealing
with the columns was clunkier than the same operation over the rows.

Addition, however, is not the primary task for which programmers and
mathematicians use matrices. No, the more interesting operation is *matrix
multiplication.* Matrix multiplication, unlike your everyday multiplication, has
a stronger type, and requires our two matrices to have an equal dimension
between them. That is, the matrix on the left must have the same width as the
height of the matrix on the right. That is, given `a : Matrix m n` and `b :
Matrix n p`, we can write the operation `a *‚Çò b` in symbols as:

$$
\begin{bmatrix}
a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\
a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\
\vdots & \vdots & \ddots & \vdots \\
a_{m,1} & a_{m,2} & \cdots & a_{m,n}
\end{bmatrix}
\times
\begin{bmatrix}
b_{1,1} & b_{1,2} & \cdots & b_{1,p}\\
b_{2,1} & b_{2,2} & \cdots & b_{2,p}\\
\vdots & \vdots & \ddots & \vdots \\
b_{n,1} & b_{n,2} & \cdots & b_{n,p}
\end{bmatrix}
$$

with the result being `c : Matrix m p`, where each cell is given by the formula:

$$
c_{i,j} = \sum_{k = 1}^{n} a_{i,k} \times b_{k, j}
$$

Said another way, the product matrix resulting from a multiplication pairs the
rows of the first matrix with the columns of the second, adding each cell up
pointwise.

If this is your first time seeing matrix multiplication (or even if it isn't,)
it might be unclear what the *intuition* behind matrix multiplication is. Why
does it exist, what does it do, and why should we care about it? We will return
to this question in a moment, but for the time being, resign ourselves to
implementing it in our row-major matrix representation.

We will implement matrix multiplication in two steps; first, by computing the
*outer-product*, which is the analogous operation on vectors (matrices with one
dimension set to 1.) The outer product of two vectors is a matrix using the
length of the first as its height, and the length of the second as its width. In
symbols, the result of:

$$
\begin{bmatrix}
a_{1} \\
a_{2} \\
\vdots \
a_{m}
\end{bmatrix}
\otimes
\begin{bmatrix}
b_{1} \\
b_{2} \\
\vdots \
b_{n}
\end{bmatrix}
$$

is a matrix:

$$
\begin{bmatrix}
a_{1}\times b_{1} & a_{1}\times b_{2} & \cdots & a_{1}\times b_{n}\\
a_{2}\times b_{1} & a_{2}\times b_{2} & \cdots & a_{2}\times b_{n}\\
\vdots & \vdots & \ddots & \vdots \\
a_{m}\times b_{1} & a_{m}\times b_{2} & \cdots & a_{m}\times b_{n}
\end{bmatrix}
$$

It's not too tricky to implement such a thing in Agda; the secret is to write
down the type and use the type-checker to help us ensure that we haven't lost a
case anywhere.

```agda
  open Data.Vec
    using (map)

  postulate
    _*_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏

  _‚äó_ : Vec ùî∏ m ‚Üí Vec ùî∏ n ‚Üí Matrix m n
  []       ‚äó ys = []
  (x ‚à∑ xs) ‚äó ys = map (x *_) ys ‚à∑ xs ‚äó ys
```

Now that we have the outer product, we can implement matrix multiplication by
taking the outer product of each row/column pair and doing a matrix addition
with the multiplication of the rest of the matrix. Start with the type:

```agda
  _*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p
```

Recall that in the definition of matrix multiplication, the *columns* of the
first matrix get paired with the *rows* of the latter. Since our matrices are in
row-major order, our induction naturally will proceed on the second argument,
since that's where the rows are. If we're out of rows, the result is
conceptually zero, but that doesn't typecheck, so instead we use `0‚Çò` which is
the matrix analogue:

```agda
  x *‚Çò [] = 0‚Çò
```

Otherwise, we must pair a column from `x` with the row we just pulled off. We
can use `left/rest` to get the column, and then proceed with our outer product
added to the resultant multiplication:

```agda
  x *‚Çò (r ‚à∑ rs) =
    let c , cs = left/rest x
      in (c ‚äó r) +‚Çò (cs *‚Çò rs)
```

As it happens, this definition of `_*‚Çò_` *is* indeed correct, but it's rather
hard to convince ourselves of that, isn't it? Recall the definition we gave
earlier, where the $c_{i,j}$ element in the resultant matrix was given by the
formula:

$$
c_{i,j} = \sum_{k = 1}^{n} a_{i,k} \times b_{k, j}
$$

Our implementation instead gives us a recursive definition:

$$
a \times_m b = (a_{-, 1} \otimes b_{1, -}) +_m ((a_{-, 2\dots}) \times_m (b_{2\dots, -}))
$$

which uses nonstandard notation to suggest pulling a column off a matrix via
$a_{-, 1}$ and the rest of the matrix as $a_{-, 2\dots}$. We can convince
ourselves of the correctness here by noticing that the induction is actually on
`p`, which means the rows and the columns on which we're doing the outer product
remain of length `m` and `n` respectively. Thus, each outer product still
results in a matrix of size $m \times n$, of which we add up exactly `p` in
number. Thus, our definition here performs `p` matrix additions, while the
mathematical definition performs `p` scalar additions in each cell.

These two definitions are thus equivalent, but there is significantly more
algebraic manipulation necessary to use `_*‚Çò_` as written. Notice that if we
wanted to prove anything about it, we would first need to inline the definitions
of `left/rest`, `_‚äó_`, and `_+‚Çò_`, each of which is annoyingly recursive and
none of which will Agda automatically compute for us. It's thus rather more work
than we'd like to do! In choosing the row-major order as our representation,
we've obscured the mathematics we're trying to prove. Not only do we need to
still do the original mathematics, we also need to juggle the weight of our
representation.


### Function Representation

Rather than go forward with the row-major representation, we will try again with
a different representation and see how all the same things roll-out. We note
that where things really went wrong was that rows and columns were citizens of
differing standing. It was easy to work with rows, but difficult to work with
columns. Of course, we could always try a column-major ordering instead, but
that would merely move the challenges.

Instead, we find ourselves looking for a representation which doesn't make any
distinctions between the two dimensions. Any sort of inductive definition is
sure to build up matrices from smaller matrices, which is likely to give rise to
the same issues. Let's thus turn our attention to a function representation:

```agda
module matrix-functions {ùî∏ : Set} where
  open import Data.Nat
    using (‚Ñï; zero; suc)
  open import Data.Fin
    using (Fin; zero; suc)

  Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
  Matrix m n = (i : Fin m) ‚Üí (j : Fin n) ‚Üí ùî∏
```

A matrix is thus parameterized by its dimensions, and is represented by a
function which takes those indices and gives you back an element of `ùî∏`. Giving
names to the `Fin` arguments here isn't strictly necessary, but it helps Agda
give meaningful names to indices as we work with matrices.

We can implement the zero matrix trivially, by simply ignoring the indices:

```agda
  private variable
    m n p : ‚Ñï

  postulate 0# : ùî∏

  0‚Çò : Matrix m n
  0‚Çò _ _ = 0#
```

Furthermore, we can now implement the identity matrix straightforwardly. In
symbols, the identity function is a square ($n \times n$) matrix whose cells are
given by:

$$
c_{i,j} =
\begin{cases}
  1 & i = j \\
  0 & \text{otherwise}
\end{cases}
$$

In Agda:

```agda
  open import Data.Bool
    using (Bool; true; false; if_then_else_)

  _==_ : Fin n ‚Üí Fin n ‚Üí Bool
  zero == zero = true
  zero == suc y = false
  suc x == zero = false
  suc x == suc y = x == y

  postulate 1# : ùî∏

  1‚Çò : Matrix m m
  1‚Çò i j = if i == j then 1# else 0#
```

We can implement the summation operator by way of `sum`, which takes a function
out of `Fin n` and adds up every term:

```agda
  postulate
    _+_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏

  open import Function
    using (id; _‚àò_)

  sum : (Fin n ‚Üí ùî∏) ‚Üí ùî∏
  sum {zero} v = 0#
  sum {suc n} v = v zero + sum {n} (v ‚àò suc)
```

With all of these pieces under our belt, the definition of matrix multiplication
is now extremely simple, and mirrors its mathematical counterpart exactly:

```agda
  postulate
    _*_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏

  _*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p
  (a *‚Çò b) i j = sum Œª k ‚Üí a i k * b k j
```

Implementing matrix addition is also exceptionally easy under our new scheme,
corresponding again exactly with the mathematical definition:

```agda
  _+‚Çò_ : Matrix m n ‚Üí Matrix m n ‚Üí Matrix m n
  (a +‚Çò b) i j = a i j + b i j
```

With a little bit of machinery in order to express equality of matrices:

```agda
  open import Relation.Binary.PropositionalEquality

  infix 0 _‚â°‚Çò_
  _‚â°‚Çò_ : (a b : Matrix m n) ‚Üí Set
  a ‚â°‚Çò b = ‚àÄ i j ‚Üí a i j ‚â° b i j
```

We can now prove `+‚Çò-identityÀ°` again.

```agda
  postulate
    +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x

  +‚Çò-identityÀ° : (a : Matrix m n) ‚Üí 0‚Çò +‚Çò a ‚â°‚Çò a
  +‚Çò-identityÀ° a i j
    rewrite +-identityÀ° (a i j)
      = refl
```

Compare the simplicity of this proof to the previous one we wrote for the
row-major implementation:

```agda
--  +‚Çò-identityÀ° ([] ‚à∑ rs)
--    rewrite +‚Çò-identityÀ° rs
--      = refl
--  +‚Çò-identityÀ° ((c ‚à∑ cs) ‚à∑ rs)
--    rewrite +-identityÀ° c
--    rewrite +‚Çò-identityÀ° rs
--      = cong (Œª œÜ ‚Üí (c ‚à∑ œÜ) ‚à∑ rs) (lemma cs)
--    where
--      lemma
--          : ‚àÄ {m} (cs : Vec ùî∏ m)
--          ‚Üí zipWith _+_ (replicate 0#) cs ‚â° cs
--      lemma [] = refl
--      lemma (c ‚à∑ cs)
--        rewrite +-identityÀ° c
--        rewrite lemma cs
--          = refl
```

Clearly we are onto something with our new representation.








```agda
open import Data.Nat using (‚Ñï; zero; suc)
private variable
  m n p : ‚Ñï
  c ‚Ñì : Agda.Primitive.Level
  A B C : Set ‚Ñì

open import Function using (id; _‚àò_)
open import Relation.Binary.PropositionalEquality

open import Algebra
  using (Semiring)
```

```agda
module WithSemiring‚ÇÇ (R : Semiring c ‚Ñì) where
    open Semiring R renaming (Carrier to X) using (0#; 1#; _+_; _*_)

    open import Data.Fin using (Fin; zero; suc)

    Vec : ‚Ñï ‚Üí Set c
    Vec m = Fin m ‚Üí X

    postulate
      fin-ext : {v‚ÇÅ v‚ÇÇ : Vec m} ‚Üí (‚àÄ i ‚Üí v‚ÇÅ i ‚â° v‚ÇÇ i) ‚Üí v‚ÇÅ ‚â° v‚ÇÇ

    postulate
      *-zeroÀ° : ‚àÄ x ‚Üí 0# * x ‚â° 0#
      *-zero ≥ : ‚àÄ x ‚Üí x * 0# ‚â° 0#
      +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x
      +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x
      *-identityÀ° : ‚àÄ x ‚Üí 1# * x ‚â° x
      *-+-distribÀ° : ‚àÄ x y z ‚Üí z * (x + y) ‚â° z * x + z * y
      *-+-distrib ≥ : ‚àÄ x y z ‚Üí (x + y) * z ‚â° x * z + y * z
      *-comm : ‚àÄ x y ‚Üí x * y ‚â° y * x

    Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set c
    Matrix m n = Fin m ‚Üí Fin n ‚Üí X

    0‚Çò : Matrix m n
    0‚Çò _ _ = 0#

    open import Data.Bool using (Bool; true; false; if_then_else_)

    _==_ : Fin n ‚Üí Fin n ‚Üí Bool
    zero == zero = true
    zero == suc y = false
    suc x == zero = false
    suc x == suc y = x == y

    1‚Çò : Matrix m m
    1‚Çò i j = if i == j then 1# else 0#

    sum : Vec n ‚Üí X
    sum {zero} v = 0#
    sum {suc n} v = v zero + sum {n} (v ‚àò suc)

    sum/0* : (f : Fin m ‚Üí X) ‚Üí sum (Œª j ‚Üí 0# * f j) ‚â° 0#
    sum/0* {zero} f = refl
    sum/0* {suc m} f
      rewrite sum/0* {m} (f ‚àò suc)
            | *-zeroÀ° (f zero)
            | +-identity ≥ 0#
            = refl


    _*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p
    (m‚ÇÅ *‚Çò m‚ÇÇ) i k = sum Œª j ‚Üí m‚ÇÅ i j * m‚ÇÇ j k

    column : Vec m ‚Üí Matrix m 1
    column v i _ = v i

    ‚åä_‚åã : Matrix m n ‚Üí Vec n ‚Üí Vec m
    ‚åä m ‚åã v i = (m *‚Çò column v) i zero
```

We will first need a little lemma that states that the sum of anything
pointwise-multiplied by zero is also zero:

```agda
    sum/*0 : (f : Fin m ‚Üí X) ‚Üí sum (Œª j ‚Üí f j * 0#) ‚â° 0#
    sum/*0 {zero} f = refl
    sum/*0 {suc m} f
      rewrite sum/*0 {m} (f ‚àò suc)
            | *-zero ≥ (f zero)
            | +-identityÀ° 0#
            = refl
```

And we are now ready to show the first of two facts demonstrating that matrices
are just encodings of functions. The first is that `‚åä 1‚Çò ‚åã` corresponds to the
`id` function:

```agda
    ‚åä1‚Çò‚åã : (x : Vec m)
         ‚Üí (i : Fin m)
         ‚Üí ‚åä 1‚Çò {m} ‚åã x i ‚â° x i
```

The type here would be clearer as `‚åä 1‚Çò {m} ‚åã ‚âó id`, but adding in the `x` and
`i` points allow us to avoid dealing with function extentionality in our proof.
The proof itself is straightforward: pattern match on `i`, and add rewrites to
eliminate the obvious algebraic identities:

```agda
    ‚åä1‚Çò‚åã x zero
      rewrite (*-identityÀ° (x zero))
            | sum/0* (x ‚àò suc)
            | +-identity ≥ (x zero)
            = refl
    ‚åä1‚Çò‚åã x (suc i)
      rewrite (*-zeroÀ° (x zero))
            | ‚åä1‚Çò‚åã (x ‚àò suc) i
            | +-identityÀ° (x (suc i))
            = refl
```


```agda
    *‚Çò‚ü∂‚àò
      : (m‚ÇÅ : Matrix m n)
      ‚Üí (m‚ÇÇ : Matrix n p)
      ‚Üí (v : Vec p)
      ‚Üí (i : Fin m)
      ‚Üí ‚åä m‚ÇÅ *‚Çò m‚ÇÇ ‚åã v i ‚â° (‚åä m‚ÇÅ ‚åã ‚àò ‚åä m‚ÇÇ ‚åã) v i
```

Giving a proof of `*‚Çò‚ü∂‚àò` isn't particularly hard on a conceptual level, although
Agda forces us to jump through several hoops to make everything work out
properly. Now that we are working with the function representation of matrices,
we no longer need to play silly games doing induction on the shape of the
matrix; instead, we can do induction on the indices. By binding the implicits
`m`, `n` and `p`, we can see what subgoals fall out when we try destructing on
each.

Destructing on `m` doesn't help simplify anything, but we notice that when
either `n = zero` or `p = zero`, the whole expression must simplify down to
`0#`. Let's do those two cases first, leaving the `suc`/`suc` case for later:

```agda
    *‚Çò‚ü∂‚àò {m} {n} {zero} m‚ÇÅ m‚ÇÇ v i rewrite sum/*0 (m‚ÇÅ i) = refl
    *‚Çò‚ü∂‚àò {m} {zero} {p} m‚ÇÅ m‚ÇÇ v i rewrite sum/0* v = refl
```

We start by opening a new `‚â°-Reasoning block:

```agda
    *‚Çò‚ü∂‚àò {m} {suc n} {suc p} m‚ÇÅ m‚ÇÇ v i = begin
        ‚åä m‚ÇÅ *‚Çò m‚ÇÇ ‚åã v i
```

Unfortunately, our usual tool of dropping down a reflexive hole and asking Agdda
to normalize-solve it doesn't work here:

```agda
      ‚â°‚ü®‚ü©
        (m‚ÇÅ *‚Çò m‚ÇÇ) i zero * column v zero zero + sum (Œª x ‚Üí (m‚ÇÅ *‚Çò m‚ÇÇ) i (suc x) * column v (suc x) zero)
```

The issue is that Agda is trying to be *too helpful* here and doing an awful job
of it. In fact, Agda normalizes our expression past the point at which the proof
becomes obvious. The solution is tedious, but we must expand out our definitions
ourselves, first, with `‚åä_‚åã`:

```agda
      ‚â°‚ü®‚ü©
        ((m‚ÇÅ *‚Çò m‚ÇÇ) *‚Çò column v) i zero
```

and then the outermost `_*‚Çò_`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí (m‚ÇÅ *‚Çò m‚ÇÇ) i j * (column v) j zero)
```

We can now eliminate `column`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí (m‚ÇÅ *‚Çò m‚ÇÇ) i j * v j)
```

and then the remaining `_*‚Çò_`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) * column v j zero)
```

Again, eliminate the `column`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) * v j)
```

Playing the same game, except from the bottom up, we arrive at:

```agda
      ‚â°‚ü® lemma ‚ü©
        sum (Œª k ‚Üí m‚ÇÅ i k * sum (Œª j ‚Üí m‚ÇÇ k j * v j))
      ‚â°‚ü®‚ü©  -- eliminate column
        sum (Œª k ‚Üí m‚ÇÅ i k * sum (Œª j ‚Üí m‚ÇÇ k j * column v j zero))
      ‚â°‚ü®‚ü©  -- expand _*‚Çò_
        sum (Œª k ‚Üí m‚ÇÅ i k * (m‚ÇÇ *‚Çò column v) k zero)
      ‚â°‚ü®‚ü©  -- expand ‚åä_‚åã
        sum (Œª k ‚Üí m‚ÇÅ i k * ‚åä m‚ÇÇ ‚åã v k)
      ‚â°‚ü®‚ü©  -- eliminate column
        sum (Œª k ‚Üí m‚ÇÅ i k * column (‚åä m‚ÇÇ ‚åã v) k zero)
      ‚â°‚ü®‚ü©  -- expand  _*‚Çò_
        (m‚ÇÅ *‚Çò column (‚åä m‚ÇÇ ‚åã v)) i zero
      ‚â°‚ü®‚ü©  -- expand ‚åä_‚åã
        ‚åä m‚ÇÅ ‚åã (‚åä m‚ÇÇ ‚åã v) i
      ‚â°‚ü®‚ü©  -- expand _‚àò_
        (‚åä m‚ÇÅ ‚åã ‚àò ‚åä m‚ÇÇ ‚åã) v i
        ‚àé
      where
        open ‚â°-Reasoning
```

Most of the work in this proof this proof is already done; it comes from
performing *just enough* evaluation of terms to see that `lemma` is the
interesting piece of the proof. Adding `lemma` to our `where` block:

```agda
        postulate
          lemma
            : sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) * v j)
            ‚â° sum (Œª k ‚Üí m‚ÇÅ i k * sum (Œª j ‚Üí m‚ÇÇ k j * v j))
```

we can inspect its type. From here, it's easy to spot that is a trivial fact of
algebra. We must prove the fact that:

$$
\sum_{j}{\left(\sum_{k} {m_{1ik} \times m_{2kj}\right) \times v_j} =
\sum_{k}{m_{1ik} \times \sum_{j} {m_{2kj} \times v_j}
$$

The proof (in Agda) is uninteresting and tedious, thus we will omit it from
presentation here, satisfying ourselves with a postulate. The result, however,
is straightforward, relying only on the associativity and distributivity of
multiplication, and the commutativity of addition:

$$
\begin{align}
\sum_{j}{\left(\sum_{k} {m_{1ik} \times m_{2kj}\right)} \times v_j}
  &= \sum_{j}{\sum_{k} {m_{1ik} \times m_{2kj} \times v_j}} \\
  &= \sum_{k}{\sum_{j} {m_{1ik} \times m_{2kj} \times v_j}} \\
  &= \sum_{k}{m_{1ik} \times \sum_{k} {m_{1ik} \times m_{2kj} \times v_j}}
\end{align}
$$

Here are the gory details if you aren't happy postulating `lemma`:

```agda
            -- ‚â°‚ü® cong sum (fin-ext Œª j ‚Üí sum-scalar (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) (v j))  ‚ü©
        -- sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j * v j))
            -- ‚â°‚ü® sum-sum (Œª j k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j * v j) ‚ü©
        -- sum (Œª k ‚Üí sum (Œª j ‚Üí m‚ÇÅ i k * m‚ÇÇ k j * v j))    ‚â°‚ü® obvious ‚ü©
        -- sum (Œª k ‚Üí sum (Œª j ‚Üí m‚ÇÅ i k * (m‚ÇÇ k j * v j)))  ‚â°‚ü® obvious ‚ü©

    sum-scalar : (f : Fin m ‚Üí X) ‚Üí (y : X) ‚Üí sum (Œª x ‚Üí f x) * y ‚â° sum (Œª x ‚Üí f x * y)
    sum-scalar {zero} f y = *-zeroÀ° y
    sum-scalar {suc m} f y =
      begin
        (f zero + sum (Œª x ‚Üí f (suc x))) * y
      ‚â°‚ü® *-+-distrib ≥ (f zero) _ y ‚ü©
        f zero * y + sum (Œª x ‚Üí f (suc x)) * y
      ‚â°‚ü® cong (f zero * y +_) (sum-scalar (f ‚àò suc) y) ‚ü©
        f zero * y + sum (Œª x ‚Üí f (suc x) * y)
      ‚àé
      where open ‚â°-Reasoning

    postulate
      obvious : {x y : X} ‚Üí x ‚â° y

    +-sum : (f‚ÇÅ f‚ÇÇ : Fin m ‚Üí X) ‚Üí sum f‚ÇÅ + sum f‚ÇÇ ‚â° sum (Œª x ‚Üí f‚ÇÅ x + f‚ÇÇ x)
    +-sum {zero} f‚ÇÅ f‚ÇÇ = +-identity ≥ 0#
    +-sum {suc m} f‚ÇÅ f‚ÇÇ =
      begin
        f‚ÇÅ zero + sum (Œª x ‚Üí f‚ÇÅ (suc x)) + (f‚ÇÇ zero + sum (Œª x ‚Üí f‚ÇÇ (suc x)))
      ‚â°‚ü® obvious ‚ü©
        f‚ÇÅ zero + f‚ÇÇ zero + (sum (Œª x ‚Üí f‚ÇÅ (suc x)) + sum (Œª x ‚Üí f‚ÇÇ (suc x)))
      ‚â°‚ü® cong (Œª œÜ ‚Üí f‚ÇÅ zero + f‚ÇÇ zero + œÜ) (+-sum (f‚ÇÅ ‚àò suc) (f‚ÇÇ ‚àò suc)) ‚ü©
        f‚ÇÅ zero + f‚ÇÇ zero + sum (Œª x ‚Üí f‚ÇÅ (suc x) + f‚ÇÇ (suc x))
      ‚àé
      where
        open ‚â°-Reasoning


    sum-sum : (f : Fin m ‚Üí Fin n ‚Üí X) ‚Üí sum (Œª j ‚Üí sum (Œª k ‚Üí f j k)) ‚â° sum (Œª k ‚Üí sum (Œª j ‚Üí f j k))
    sum-sum {zero} {zero} f = refl
    sum-sum {zero} {suc n} f = obvious
    sum-sum {suc m} {zero} f = obvious
    sum-sum {suc m} {suc n} f =
      begin
        sum {suc m} (Œª j ‚Üí sum {suc n} (Œª k ‚Üí f j k))
      ‚â°‚ü®‚ü©
        sum {suc n} (Œª k ‚Üí f zero k) + sum {m} (Œª j ‚Üí sum {suc n} (Œª k ‚Üí f (suc j) k))
      ‚â°‚ü® cong (Œª œÜ ‚Üí sum {suc n} (Œª k ‚Üí f zero k) + œÜ) (sum-sum (Œª j k ‚Üí f (suc j) k)) ‚ü©
        sum {suc n} (Œª k ‚Üí f zero k) + sum {suc n} (Œª k ‚Üí sum {m} (Œª j ‚Üí f (suc j) k))
      ‚â°‚ü® +-sum (Œª k ‚Üí f zero k) (Œª k ‚Üí sum {m} (Œª j ‚Üí f (suc j) k)) ‚ü©
        sum {suc n} (Œª k ‚Üí f zero k + sum {m} (Œª j ‚Üí f (suc j) k))
      ‚â°‚ü®‚ü©
        sum {suc n} (Œª k ‚Üí sum {suc m} (Œª j ‚Üí f j k))
      ‚àé
      where open ‚â°-Reasoning
```

So, what kind of functions are representable as matrices? As it happens, they
are precisely the *linear maps* --- that is, the two properties must hold:

```agda
    map : (X ‚Üí X) ‚Üí Vec m ‚Üí Vec m
    map f v i = f (v i)

    zip : (X ‚Üí X ‚Üí X) ‚Üí Vec m ‚Üí Vec m ‚Üí Vec m
    zip f v‚ÇÅ v‚ÇÇ i = f (v‚ÇÅ i) (v‚ÇÇ i)

    record LinearFunction (f : Vec m ‚Üí Vec n) : Set c where
      field
        additive : ‚àÄ v‚ÇÅ v‚ÇÇ ‚Üí f (zip _+_ v‚ÇÅ v‚ÇÇ) ‚âó zip _+_ (f v‚ÇÅ) (f v‚ÇÇ)
        homogeneity : ‚àÄ v x ‚Üí f (map (x *_) v) ‚âó map (x *_) (f v)
    open LinearFunction

    ‚åä‚åã-linear : (M : Matrix m n) ‚Üí LinearFunction ‚åä M ‚åã
    additive (‚åä‚åã-linear M) v‚ÇÅ v‚ÇÇ i =
      begin
        ‚åä M ‚åã (zip _+_ v‚ÇÅ v‚ÇÇ) i
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí M i j * (v‚ÇÅ j + v‚ÇÇ j))
      ‚â°‚ü® cong sum (fin-ext Œª j ‚Üí *-+-distribÀ° _ _ (M i j)) ‚ü©
        sum (Œª j ‚Üí M i j * v‚ÇÅ j + M i j * v‚ÇÇ j)
      ‚â°‚ü® sym (+-sum (Œª j ‚Üí M i j * v‚ÇÅ j) (Œª j ‚Üí M i j * v‚ÇÇ j)) ‚ü©
        sum (Œª j ‚Üí M i j * v‚ÇÅ j) + sum (Œª j ‚Üí M i j * v‚ÇÇ j)
      ‚â°‚ü®‚ü©
        ‚åä M ‚åã v‚ÇÅ i + ‚åä M ‚åã v‚ÇÇ i
      ‚àé
      where open ‚â°-Reasoning
    homogeneity (‚åä‚åã-linear M) v x i =
      begin
        ‚åä M ‚åã (map (x *_) v) i
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí M i j * (x * v j))
      ‚â°‚ü® obvious ‚ü©
        sum (Œª j ‚Üí M i j * (v j * x))
      ‚â°‚ü® obvious ‚ü©
        sum (Œª j ‚Üí (M i j * v j) * x)
      ‚â°‚ü® obvious ‚ü©
        sum (Œª j ‚Üí (M i j * v j) * x)
      ‚â°‚ü® sym (sum-scalar (Œª j ‚Üí (M i j * v j)) x) ‚ü©
        sum (Œª j ‚Üí M i j * v j) * x
      ‚â°‚ü® *-comm _ x ‚ü©
        x * sum (Œª j ‚Üí M i j * v j)
      ‚â°‚ü®‚ü©
        map (x *_) (‚åä M ‚åã v) i
      ‚àé
      where open ‚â°-Reasoning
```

```agda

open import Data.Bool using (true; false)
open import Relation.Nullary using (Dec; yes; no; _because_; of ∏)

module dictionaries {K : Set} (_‚âü_ : (x y : K) ‚Üí Dec (x ‚â° y)) where
  open import Data.Maybe using (Maybe; just; nothing)
  open import Data.Product using (_√ó_; _,_; ‚àÉ; Œ£; proj‚ÇÅ; proj‚ÇÇ)

  open import Data.List using (List; []; _‚à∑_; map)
  open import Data.List.Relation.Unary.All using (All; []; _‚à∑_)
  open import Data.List.Relation.Unary.AllPairs using (AllPairs; []; _‚à∑_)
  open import Data.List.Relation.Unary.Unique.Propositional using (Unique; []; _‚à∑_)

  private variable
    V : Set

  UniqueAssocList : (K V : Set) ‚Üí List (K √ó V) ‚Üí Set
  UniqueAssocList _ _ = AllPairs Œª { (k‚ÇÅ , _) (k‚ÇÇ , _) ‚Üí k‚ÇÅ ‚â¢ k‚ÇÇ }

  Dict : Set ‚Üí Set ‚Üí Set
  Dict K V = ‚àÉ (UniqueAssocList K V)

  lookup : List (K √ó V) ‚Üí K ‚Üí Maybe V
  lookup [] i = nothing
  lookup ((k , v) ‚à∑ l) i with i ‚âü k
  ... | yes refl = just v
  ... | no _ = lookup l i

  ‚åä_‚åã : Dict K V ‚Üí (K ‚Üí Maybe V)
  ‚åä l , _ ‚åã = lookup l

  data Preimage_‚àã_ (f : K ‚Üí Maybe V) : K ‚Üí Set where
    im : ‚àÄ {x} y ‚Üí f x ‚â° just y ‚Üí Preimage f ‚àã x

  open import Data.List.Membership.Propositional

  record ComputablePreimage (f : K ‚Üí Maybe V) (l : List K) : Set where
    field
      is-unique : Unique l
      is-preimage : All (Preimage f ‚àã_) l
      is-total : ‚àÄ k v ‚Üí f k ‚â° just v ‚Üí k ‚àà l
  open ComputablePreimage

  preimage : Dict K V ‚Üí List K
  preimage (l , _) = map proj‚ÇÅ l

  open import Data.List.Relation.Unary.Unique.Propositional.Properties

  postulate
    ‚âü-refl : ‚àÄ k ‚Üí k ‚âü k ‚â° (true because of ∏ refl)

  open import Data.Empty using (‚ä•-elim)


--   ‚åä‚åã-preimage : (d : Dict K V) ‚Üí ComputablePreimage ‚åä d ‚åã (preimage d)
--   is-unique (‚åä‚åã-preimage (l , u)) = map‚Å∫ ? ?
--   is-preimage (‚åä‚åã-preimage ([] , _)) = []
--   is-preimage (‚åä‚åã-preimage d@((k , v) ‚à∑ l , _ ‚à∑ p)) with ‚åä d ‚åã k in eq
--   ... | just v rewrite eq = im v eq ‚à∑ is-preimage {! ‚åä‚åã-preimage (l , p) !}
--   ... | nothing = ‚ä•-elim {! !}
--   is-total (‚åä‚åã-preimage d) = {! !}

-- Fuck preimages.
```

subsets


