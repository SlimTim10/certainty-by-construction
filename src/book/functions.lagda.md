# Functions, Big and Small

```agda
module functions where
```

Computer science is chocked full of data structures. A great many come from the
official pantheon---things like binary search trees, hash maps, stacks, graphs,
and heaps. But, dwarfing all of these, there exists orders of magnitude more
data structures in the arcane vault, from the
passingly-familiar-but-unlikely-to-have-implemented *rope* to the obscure *Judy
array.* With so many options to choose from, how can we even hope to make an
informed choice?

The reason there exist many more data structures than any practitioner can
possibly know about is that most data structures are minor tweaks of other
well-known structures. For example, the UB-tree is a variation on the B+ tree,
which itself is a B-tree that maintains a particular invariant, while a B-tree
is a generalization of the binary search tree (BST henceforth). Unrolling the
lineage here shows us that whatever the UB-tree is, it's probably a BST that has
more desirable computational properties for certain shapes of data.

As Donald Knuth said, "premature optimization is the root of all evil." For the
vast majority of tasks, you can start with (and subsequently get away with) a
BST, upgrading to the more complex UB-tree in the future only if it turns out to
be mission critical. This is a well-understood idea in the modern age.

However, most programmers coming to Agda make an error in the spirit of the
Co-Blub paradox. After years of honing their taste and cutting their teeth on
picking the simplest data structure for the job, they come to Agda and
immediately fall down the rabbit-hole of long, arduous proofs. As I have gotten
older and more experienced, my guiding philosophy for writing software has
become *if it feels too hard, it probably is.*

As it happens, your choice of representation matters much more in Agda than it
does in most programming languages. That arises from the fact that your proofs
will inevitably trace the same grooves as the implementations they are proofs
*about.* In other words, the proof follows the implementation. It's not hard to
imagine that a complicated implementation will warrant a complicated proof.


## Matrices

Let's work through an example together, to get a feel for just how important a
representation can be. Our object of investigation will be *matrices*---that is,
rectangular arrays of numbers. Matrices are often used in computational
geometry, including 3D graphics, and are the back-bone of modern machine
learning techniques. As an exercise in honing our
translating-mathematics-to-Agda chops, let's take a look at the definition of a
matrix.

Matrix
:   A rectangular array of numbers.

Matrices have a predefined height and width, often referred to as $m$ and $n$
respectively, and given in that order. For example, the following is a 3x2
matrix:

```text
1   1
5  -42
0  2.5
```

Note that the numbers inside a matrix are rather flexible. Depending on the
circumstances, we might prefer them to be naturals, while in others we might
want reals, or even functions. In order to avoid the complexities here, we will
simply parameterize the our module over the type of numbers, and postulate any
properties of those numbers as the need occurs. Let's call this number type
parameter `ùî∏`:

```agda
module matrix‚ÇÅ {ùî∏ : Set} where
```

Returning to the problem of modeling matrices in Agda, note that we don't have
any good, inductive primitives for two-dimensional data, I think most
programmers would thus come up with the next best thing: the "vector of vectors"
model---indeed, it's what I first thought of.

```agda
  open import Data.Product
    as Œ£
    using (_√ó_; _,_)
  open import Data.Nat
    using (‚Ñï; zero; suc)
  open import Data.Vec
    using (Vec; []; _‚à∑_)

  Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
  Matrix m n = Vec (Vec ùî∏ n) m

  private variable
    m n p : ‚Ñï
```

This representation is known as the "row-major order" of matrices, that is, the
rows have contiguous data, while the columns do not. There are immediate
repercussions here. For example, let's implement the function `top/rest` which
separates the first row from the rest of the matrix:

```agda
  top/rest
      : Matrix (suc m) n
      ‚Üí Vec ùî∏ n √ó Matrix m n
  top/rest (x ‚à∑ xs) = x , xs
```

Compare `top/rest` to the analogous function that pulls the leftmost column off
of a matrix:

```agda
  left/rest
      : Matrix m (suc n)
      ‚Üí Vec ùî∏ m √ó Matrix m n
  left/rest [] = [] , []
  left/rest ((x ‚à∑ v) ‚à∑ m)
    = Œ£.map (x ‚à∑_) (v ‚à∑_) (left/rest m)
```

The dramatic difference in complexity between these two analogous functions is
telling. Clearly, row-major order significantly privileges working with rows
over working with columns.

Nevertheless, we can continue by implementing a few special matrices of note.
First is the zero-matrix, which is the matrix that is full only of zeroes. Note
that we will also need to postulate the existence of `0# : ùî∏`.

```agda
  postulate 0# : ùî∏

  open Data.Vec
    using (replicate)

  0‚Çò : Matrix m n
  0‚Çò = replicate (replicate 0#)
```

Two matrices of the same dimensions support a kind of addition, given by adding
the respective cells in each of the two columns. That is:

$$
\begin{bmatrix}
a & b & c\\
d & e & f
\end{bmatrix}
+
\begin{bmatrix}
x & y & z\\
t & u & v
\end{bmatrix}
=
\begin{bmatrix}
a + x & b + y & c + z\\
d + t & e + u & f + v
\end{bmatrix}
$$

We can implement this operation over matrices by positing the existence of an
addition over `ùî∏`, as well as some common-sense identity laws:

```agda
  open import Relation.Binary.PropositionalEquality

  postulate
    _+_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏
    +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x
    +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x

  open Data.Vec
    using (zipWith)
```

Addition of matrices doesn't present us any problems, as pointwise operations
don't need to distinguish between rows and columns. Thus, we can zip the rows
together, zip the corresponding cells together, and add each pair:

```agda
  _+‚Çò_ : Matrix m n ‚Üí Matrix m n ‚Üí Matrix m n
  x +‚Çò y = zipWith (zipWith _+_) x y
```

Let's now prove the trivial fact that `0‚Çò` is a left identity for `+‚Çò`:

```agda
  +‚Çò-identityÀ° : (x : Matrix m n) ‚Üí 0‚Çò +‚Çò x ‚â° x
```

We can begin, as always, with induction on our argument. The first case, in
which `m ‚â° 0`, is easy:

```agda
  +‚Çò-identityÀ° [] = refl
```

The case that `n ‚â° 0` is also easy, although slightly more work, as our
row-major order would suggest:

```agda
  +‚Çò-identityÀ° ([] ‚à∑ rs)
    rewrite +‚Çò-identityÀ° rs
      = refl
```

We're now left with the induction case. After some obvious rewriting to
eliminate the `0# +_` and the row-recursive case, we're left here:

```agda
  +‚Çò-identityÀ° ((c ‚à∑ cs) ‚à∑ rs)
    rewrite +-identityÀ° c
    rewrite +‚Çò-identityÀ° rs
```

with the goal

```goal
  (c ‚à∑ zipWith _+_ (replicate 0#) cs) ‚à∑ rs
‚â°
  (c ‚à∑ cs) ‚à∑ rs
```

and it's unclear how to move forwards. It would be nice if our induction just
worked, but, unfortunately, it doesn't. Crossing our fingers that this is not a
serious problem, we can write a little lemma to solve the goal for us:

```agda
      = cong (Œª œÜ ‚Üí (c ‚à∑ œÜ) ‚à∑ rs) (lemma cs)

    where
      lemma
          : ‚àÄ {m} (cs : Vec ùî∏ m)
          ‚Üí zipWith _+_ (replicate 0#) cs ‚â° cs
      lemma [] = refl
      lemma (c ‚à∑ cs)
        rewrite +-identityÀ° c
        rewrite lemma cs
          = refl
```

It's not the tidiest proof in the world, but it certainly gets the job done.
However, we should be wary here; this is our second function in which dealing
with the columns was clunkier than the same operation over the rows.

Addition, however, is not the primary task for which programmers and
mathematicians use matrices. No, the more interesting operation is *matrix
multiplication*







```agda
open import Data.Nat using (‚Ñï; zero; suc)
private variable
  m n p : ‚Ñï
  c ‚Ñì : Agda.Primitive.Level
  A B C : Set ‚Ñì

open import Function using (id; _‚àò_)
open import Relation.Binary.PropositionalEquality

open import Algebra
  using (Semiring)
module matrices where
  -- presentation as given by
  -- https://personal.cis.strath.ac.uk/james.wood.100/blog/html/VecMat.html
  open import Data.Vec

  Matrix : Set c ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Set c
  Matrix A m n = Vec (Vec A n) m

  open import Data.Product
    using (_√ó_; _,_)
  import Data.Product as Œ£

  left/rest : Matrix A m (suc n) ‚Üí Vec A m √ó Matrix A m n
  left/rest [] = [] , []
  left/rest ((x ‚à∑ v) ‚à∑ m) = Œ£.map (x ‚à∑_) (v ‚à∑_) (left/rest m)

  outer : (A ‚Üí B ‚Üí C) ‚Üí (Vec A m ‚Üí Vec B n ‚Üí Matrix C m n)
  outer f [] ys = []
  outer f (x ‚à∑ xs) ys = map (f x) ys ‚à∑ outer f xs ys

  column : Vec A m ‚Üí Matrix A m 1
  column [] = []
  column (x ‚à∑ xs) = (x ‚à∑ []) ‚à∑ column xs

  left/rest-map-‚à∑ : (x : A) (M : Matrix A m n) ‚Üí
                    left/rest (map (x ‚à∑_) M) ‚â° (replicate x , M)
  left/rest-map-‚à∑ x [] = refl
  left/rest-map-‚à∑ x (u ‚à∑ M) rewrite left/rest-map-‚à∑ x M = refl

  module WithSemiring (R : Semiring c ‚Ñì) where
    open Semiring R renaming (Carrier to X) using (0#; 1#; _+_; _*_)

    0·µ• : Vec X m
    0·µ• = replicate 0#

    _+·µ•_ : Vec X m ‚Üí Vec X m ‚Üí Vec X m
    _+·µ•_ = zipWith _+_

    _*·µ•_ : X ‚Üí Vec X m ‚Üí Vec X m
    x *·µ• y = map (x *_) y

    0‚Çò : Matrix X m n
    0‚Çò = replicate 0·µ•

    _+‚Çò_ : Matrix X m n ‚Üí Matrix X m n ‚Üí Matrix X m n
    _+‚Çò_ = zipWith _+·µ•_

    1‚Çò : Matrix X m m
    1‚Çò {zero} = []
    1‚Çò {suc m} = (1# ‚à∑ 0·µ•) ‚à∑ map (0# ‚à∑_) 1‚Çò

    _‚äó‚Çí_ : Vec X m ‚Üí Vec X n ‚Üí Matrix X m n
    _‚äó‚Çí_ = outer _*_

    _*‚Çò_ : Matrix X m n ‚Üí Matrix X n p ‚Üí Matrix X m p
    x *‚Çò [] = 0‚Çò
    x *‚Çò (y ‚à∑ ys) =
      let u , m = left/rest x
       in (u ‚äó‚Çí y) +‚Çò (m *‚Çò ys)

    _$_ : Matrix X m n ‚Üí Matrix X n 1 ‚Üí Matrix X m 1
    _$_ = _*‚Çò_

    ‚åä_‚åã : Matrix X m n ‚Üí Vec X n ‚Üí Vec X m
    ‚åä m ‚åã v with left/rest (m $ column v)
    ... | fst , _ = fst

    postulate
      *-zeroÀ° : ‚àÄ x ‚Üí 0# * x ‚â° 0#
      +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x
      +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x
      *-identityÀ° : ‚àÄ x ‚Üí 1# * x ‚â° x

    left/1‚Çò : left/rest (1‚Çò {suc m}) ‚â° ((1# ‚à∑ replicate 0#) , replicate 0# ‚à∑ 1‚Çò {m})
    left/1‚Çò {zero} = refl
    left/1‚Çò {suc m}
      rewrite left/rest-map-‚à∑ {m = m} 0# (map (0# ‚à∑_) 1‚Çò) = refl

    left/+ : (x y : Matrix X m (suc n)) ‚Üí left/rest (x +‚Çò y) ‚â° Œ£.zip‚Ä≤ (zipWith _+_) _+‚Çò_ (left/rest x) (left/rest y)
    left/+ [] [] = refl
    left/+ ((x ‚à∑ xx) ‚à∑ xs) ((y ‚à∑ yy) ‚à∑ ys) rewrite left/+ xs ys = refl

    map/*0 : ‚àÄ xs ‚Üí map {n = n} (0# *_) xs ‚â° replicate 0#
    map/*0 [] = refl
    map/*0 (x ‚à∑ xs) rewrite *-zeroÀ° x | map/*0 xs = refl

    outer/replicate0
      : {m n : ‚Ñï}
      ‚Üí (x : Vec X n)
      ‚Üí replicate {n = m} 0# ‚äó‚Çí x ‚â° replicate (replicate 0#)
    outer/replicate0 {zero} x = refl
    outer/replicate0 {suc m} [] rewrite outer/replicate0 {m} [] = refl
    outer/replicate0 {suc m} (x ‚à∑ xs)
      rewrite *-zeroÀ° x
            | map/*0 xs
            | outer/replicate0 {m} (x ‚à∑ xs)
            = refl

    postulate
      dunno : (xs : Vec X m) ‚Üí (replicate 0# ‚à∑ 1‚Çò) *‚Çò column xs ‚â° column (0# ‚à∑ xs)
    -- dunno [] = refl
    -- dunno (x ‚à∑ xs) =
    --   begin
    --     (replicate 0# ‚à∑ 1‚Çò) *‚Çò column (x ‚à∑ xs)
    --   ‚â°‚ü®‚ü©
    --     (replicate 0# ‚à∑ 1‚Çò) *‚Çò ((x ‚à∑ []) ‚à∑ column xs)
    --   ‚â°‚ü®‚ü©
    --     (Œ£.proj‚ÇÅ (left/rest (replicate 0# ‚à∑ 1‚Çò)) ‚äó‚Çí (x ‚à∑ [])) +‚Çò (Œ£.proj‚ÇÇ (left/rest (replicate 0# ‚à∑ 1‚Çò)) *‚Çò (column xs))
    --   ‚â°‚ü® ? ‚ü©
    --     (0# ‚à∑ []) ‚à∑ (x ‚à∑ []) ‚à∑ column xs
    --   ‚àé
    --   where open ‚â°-Reasoning

    left/column : (xs : Vec X m) ‚Üí left/rest (column xs) ‚â° (xs , replicate [])
    left/column [] = refl
    left/column (x ‚à∑ xs) rewrite left/column xs = refl

    left/replicate : left/rest (replicate {n = m} (0# ‚à∑ [])) ‚â° (replicate 0# , replicate [])
    left/replicate {zero} = refl
    left/replicate {suc m} rewrite left/replicate {m} = refl

    zip/0#+ : ‚àÄ xs ‚Üí zipWith _+_ (replicate {n = m} 0#) xs ‚â° xs
    zip/0#+ [] = refl
    zip/0#+ (x ‚à∑ xs) rewrite +-identityÀ° x | zip/0#+ xs = refl

    ‚åä1‚Çò‚åã : ‚åä 1‚Çò {m} ‚åã ‚âó id
    ‚åä1‚Çò‚åã {zero} [] = _‚â°_.refl
    ‚åä1‚Çò‚åã {suc m} (x ‚à∑ xs) =
      begin
        ‚åä 1‚Çò ‚åã (x ‚à∑ xs)
      ‚â°‚ü®‚ü©
        let left : ‚àÄ {m} ‚Üí Matrix X m 1 ‚Üí Vec X m
            left = Œ£.proj‚ÇÅ ‚àò left/rest in
        left (1‚Çò *‚Çò column (x ‚à∑ xs))
      ‚â°‚ü®‚ü©
        left (1‚Çò *‚Çò ((x ‚à∑ []) ‚à∑ column xs))
      ‚â°‚ü®‚ü©
        left ((Œ£.proj‚ÇÅ (left/rest (1‚Çò {suc m})) ‚äó‚Çí (x ‚à∑ [])) +‚Çò (Œ£.proj‚ÇÇ (left/rest (1‚Çò {suc m})) *‚Çò (column xs)))
      ‚â°‚ü® cong Œ£.proj‚ÇÅ (left/+ (Œ£.proj‚ÇÅ (left/rest (1‚Çò {suc m})) ‚äó‚Çí (x ‚à∑ [])) (Œ£.proj‚ÇÇ (left/rest (1‚Çò {suc m})) *‚Çò (column xs))) ‚ü©
        zipWith _+_ (left (Œ£.proj‚ÇÅ (left/rest 1‚Çò) ‚äó‚Çí (x ‚à∑ []))) (Œ£.proj‚ÇÅ (left/rest (Œ£.proj‚ÇÇ (left/rest 1‚Çò) *‚Çò column xs)))
      ‚â°‚ü® cong (Œª œÜ ‚Üí zipWith _+_ (left (Œ£.proj‚ÇÅ œÜ ‚äó‚Çí (x ‚à∑ []))) (Œ£.proj‚ÇÅ (left/rest (Œ£.proj‚ÇÇ œÜ *‚Çò column xs)))) (left/1‚Çò {m}) ‚ü©
        zipWith _+_ (left ((1# ‚à∑ replicate 0#) ‚äó‚Çí (x ‚à∑ []))) (left ((replicate 0# ‚à∑ 1‚Çò) *‚Çò column xs))
      ‚â°‚ü® cong (Œª œÜ ‚Üí zipWith _+_ (œÜ ‚à∑ left (replicate 0# ‚äó‚Çí _)) _) (*-identityÀ° x) ‚ü©
        zipWith _+_ (x ‚à∑ left (replicate 0# ‚äó‚Çí (x ‚à∑ []))) (left ((replicate 0# ‚à∑ 1‚Çò) *‚Çò column xs))
      ‚â°‚ü® cong (Œª œÜ ‚Üí zipWith _+_ (x ‚à∑ left œÜ) _) (outer/replicate0 (x ‚à∑ [])) ‚ü©
        zipWith _+_ (x ‚à∑ (left (replicate (replicate 0#)))) (left ((replicate {n = m} 0# ‚à∑ 1‚Çò {m}) *‚Çò column xs))
      ‚â°‚ü® cong (Œª œÜ ‚Üí zipWith _+_ (x ‚à∑ (left (replicate (replicate 0#)))) (left œÜ)) (dunno xs) ‚ü©
        zipWith _+_ (x ‚à∑ left (replicate (replicate 0#))) (left (column (0# ‚à∑ xs)))
      ‚â°‚ü® cong (Œª œÜ ‚Üí zipWith _+_ (x ‚à∑ left (replicate (replicate 0#))) (Œ£.proj‚ÇÅ œÜ)) (left/column (0# ‚à∑ xs)) ‚ü©
        x + 0# ‚à∑ zipWith _+_ (Œ£.proj‚ÇÅ (left/rest (replicate (0# ‚à∑ [])))) xs
      ‚â°‚ü® cong (_‚à∑ _) (+-identity ≥ x) ‚ü©
        x ‚à∑ zipWith _+_ (Œ£.proj‚ÇÅ (left/rest (replicate (0# ‚à∑ [])))) xs
      ‚â°‚ü® cong (Œª œÜ ‚Üí x ‚à∑ zipWith _+_ (Œ£.proj‚ÇÅ œÜ) xs) left/replicate ‚ü©
        x ‚à∑ zipWith _+_ (replicate 0#) xs
      ‚â°‚ü® cong (x ‚à∑_) (zip/0#+ xs) ‚ü©
        x ‚à∑ xs
      ‚àé
      where open ‚â°-Reasoning

    -- this would be a really nice thing to show
```

```agda
module WithSemiring‚ÇÇ (R : Semiring c ‚Ñì) where
    open Semiring R renaming (Carrier to X) using (0#; 1#; _+_; _*_)

    open import Data.Fin using (Fin; zero; suc)

    Vec : ‚Ñï ‚Üí Set c
    Vec m = Fin m ‚Üí X

    postulate
      fin-ext : {v‚ÇÅ v‚ÇÇ : Vec m} ‚Üí (‚àÄ i ‚Üí v‚ÇÅ i ‚â° v‚ÇÇ i) ‚Üí v‚ÇÅ ‚â° v‚ÇÇ

    postulate
      *-zeroÀ° : ‚àÄ x ‚Üí 0# * x ‚â° 0#
      *-zero ≥ : ‚àÄ x ‚Üí x * 0# ‚â° 0#
      +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x
      +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x
      *-identityÀ° : ‚àÄ x ‚Üí 1# * x ‚â° x
      *-+-distribÀ° : ‚àÄ x y z ‚Üí z * (x + y) ‚â° z * x + z * y
      *-+-distrib ≥ : ‚àÄ x y z ‚Üí (x + y) * z ‚â° x * z + y * z
      *-comm : ‚àÄ x y ‚Üí x * y ‚â° y * x

    Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set c
    Matrix m n = Fin m ‚Üí Fin n ‚Üí X

    0‚Çò : Matrix m n
    0‚Çò _ _ = 0#

    open import Data.Bool using (Bool; true; false; if_then_else_)

    _==_ : Fin n ‚Üí Fin n ‚Üí Bool
    zero == zero = true
    zero == suc y = false
    suc x == zero = false
    suc x == suc y = x == y

    1‚Çò : Matrix m m
    1‚Çò i j = if i == j then 1# else 0#

    sum : Vec n ‚Üí X
    sum {zero} v = 0#
    sum {suc n} v = v zero + sum {n} (v ‚àò suc)

    sum/0* : (f : Fin m ‚Üí X) ‚Üí sum (Œª j ‚Üí 0# * f j) ‚â° 0#
    sum/0* {zero} f = refl
    sum/0* {suc m} f
      rewrite sum/0* {m} (f ‚àò suc)
            | *-zeroÀ° (f zero)
            | +-identity ≥ 0#
            = refl


    _*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p
    (m‚ÇÅ *‚Çò m‚ÇÇ) i k = sum Œª j ‚Üí m‚ÇÅ i j * m‚ÇÇ j k

    column : Vec m ‚Üí Matrix m 1
    column v i _ = v i

    ‚åä_‚åã : Matrix m n ‚Üí Vec n ‚Üí Vec m
    ‚åä m ‚åã v i = (m *‚Çò column v) i zero
```

We will first need a little lemma that states that the sum of anything
pointwise-multiplied by zero is also zero:

```agda
    sum/*0 : (f : Fin m ‚Üí X) ‚Üí sum (Œª j ‚Üí f j * 0#) ‚â° 0#
    sum/*0 {zero} f = refl
    sum/*0 {suc m} f
      rewrite sum/*0 {m} (f ‚àò suc)
            | *-zero ≥ (f zero)
            | +-identityÀ° 0#
            = refl
```

And we are now ready to show the first of two facts demonstrating that matrices
are just encodings of functions. The first is that `‚åä 1‚Çò ‚åã` corresponds to the
`id` function:

```agda
    ‚åä1‚Çò‚åã : (x : Vec m)
         ‚Üí (i : Fin m)
         ‚Üí ‚åä 1‚Çò {m} ‚åã x i ‚â° x i
```

The type here would be clearer as `‚åä 1‚Çò {m} ‚åã ‚âó id`, but adding in the `x` and
`i` points allow us to avoid dealing with function extentionality in our proof.
The proof itself is straightforward: pattern match on `i`, and add rewrites to
eliminate the obvious algebraic identities:

```agda
    ‚åä1‚Çò‚åã x zero
      rewrite (*-identityÀ° (x zero))
            | sum/0* (x ‚àò suc)
            | +-identity ≥ (x zero)
            = refl
    ‚åä1‚Çò‚åã x (suc i)
      rewrite (*-zeroÀ° (x zero))
            | ‚åä1‚Çò‚åã (x ‚àò suc) i
            | +-identityÀ° (x (suc i))
            = refl
```


```agda
    *‚Çò‚ü∂‚àò
      : (m‚ÇÅ : Matrix m n)
      ‚Üí (m‚ÇÇ : Matrix n p)
      ‚Üí (v : Vec p)
      ‚Üí (i : Fin m)
      ‚Üí ‚åä m‚ÇÅ *‚Çò m‚ÇÇ ‚åã v i ‚â° (‚åä m‚ÇÅ ‚åã ‚àò ‚åä m‚ÇÇ ‚åã) v i
```

Giving a proof of `*‚Çò‚ü∂‚àò` isn't particularly hard on a conceptual level, although
Agda forces us to jump through several hoops to make everything work out
properly. Now that we are working with the function representation of matrices,
we no longer need to play silly games doing induction on the shape of the
matrix; instead, we can do induction on the indices. By binding the implicits
`m`, `n` and `p`, we can see what subgoals fall out when we try destructing on
each.

Destructing on `m` doesn't help simplify anything, but we notice that when
either `n = zero` or `p = zero`, the whole expression must simplify down to
`0#`. Let's do those two cases first, leaving the `suc`/`suc` case for later:

```agda
    *‚Çò‚ü∂‚àò {m} {n} {zero} m‚ÇÅ m‚ÇÇ v i rewrite sum/*0 (m‚ÇÅ i) = refl
    *‚Çò‚ü∂‚àò {m} {zero} {p} m‚ÇÅ m‚ÇÇ v i rewrite sum/0* v = refl
```

We start by opening a new `‚â°-Reasoning block:

```agda
    *‚Çò‚ü∂‚àò {m} {suc n} {suc p} m‚ÇÅ m‚ÇÇ v i = begin
        ‚åä m‚ÇÅ *‚Çò m‚ÇÇ ‚åã v i
```

Unfortunately, our usual tool of dropping down a reflexive hole and asking Agdda
to normalize-solve it doesn't work here:

```agda
      ‚â°‚ü®‚ü©
        (m‚ÇÅ *‚Çò m‚ÇÇ) i zero * column v zero zero + sum (Œª x ‚Üí (m‚ÇÅ *‚Çò m‚ÇÇ) i (suc x) * column v (suc x) zero)
```

The issue is that Agda is trying to be *too helpful* here and doing an awful job
of it. In fact, Agda normalizes our expression past the point at which the proof
becomes obvious. The solution is tedious, but we must expand out our definitions
ourselves, first, with `‚åä_‚åã`:

```agda
      ‚â°‚ü®‚ü©
        ((m‚ÇÅ *‚Çò m‚ÇÇ) *‚Çò column v) i zero
```

and then the outermost `_*‚Çò_`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí (m‚ÇÅ *‚Çò m‚ÇÇ) i j * (column v) j zero)
```

We can now eliminate `column`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí (m‚ÇÅ *‚Çò m‚ÇÇ) i j * v j)
```

and then the remaining `_*‚Çò_`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) * column v j zero)
```

Again, eliminate the `column`:

```agda
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) * v j)
```

Playing the same game, except from the bottom up, we arrive at:

```agda
      ‚â°‚ü® lemma ‚ü©
        sum (Œª k ‚Üí m‚ÇÅ i k * sum (Œª j ‚Üí m‚ÇÇ k j * v j))
      ‚â°‚ü®‚ü©  -- eliminate column
        sum (Œª k ‚Üí m‚ÇÅ i k * sum (Œª j ‚Üí m‚ÇÇ k j * column v j zero))
      ‚â°‚ü®‚ü©  -- expand _*‚Çò_
        sum (Œª k ‚Üí m‚ÇÅ i k * (m‚ÇÇ *‚Çò column v) k zero)
      ‚â°‚ü®‚ü©  -- expand ‚åä_‚åã
        sum (Œª k ‚Üí m‚ÇÅ i k * ‚åä m‚ÇÇ ‚åã v k)
      ‚â°‚ü®‚ü©  -- eliminate column
        sum (Œª k ‚Üí m‚ÇÅ i k * column (‚åä m‚ÇÇ ‚åã v) k zero)
      ‚â°‚ü®‚ü©  -- expand  _*‚Çò_
        (m‚ÇÅ *‚Çò column (‚åä m‚ÇÇ ‚åã v)) i zero
      ‚â°‚ü®‚ü©  -- expand ‚åä_‚åã
        ‚åä m‚ÇÅ ‚åã (‚åä m‚ÇÇ ‚åã v) i
      ‚â°‚ü®‚ü©  -- expand _‚àò_
        (‚åä m‚ÇÅ ‚åã ‚àò ‚åä m‚ÇÇ ‚åã) v i
        ‚àé
      where
        open ‚â°-Reasoning
```

Most of the work in this proof this proof is already done; it comes from
performing *just enough* evaluation of terms to see that `lemma` is the
interesting piece of the proof. Adding `lemma` to our `where` block:

```agda
        postulate
          lemma
            : sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) * v j)
            ‚â° sum (Œª k ‚Üí m‚ÇÅ i k * sum (Œª j ‚Üí m‚ÇÇ k j * v j))
```

we can inspect its type. From here, it's easy to spot that is a trivial fact of
algebra. We must prove the fact that:

$$
\sum_{j}{\left(\sum_{k} {m_{1ik} \times m_{2kj}\right) \times v_j} =
\sum_{k}{m_{1ik} \times \sum_{j} {m_{2kj} \times v_j}
$$

The proof (in Agda) is uninteresting and tedious, thus we will omit it from
presentation here, satisfying ourselves with a postulate. The result, however,
is straightforward, relying only on the associativity and distributivity of
multiplication, and the commutativity of addition:

$$
\begin{align}
\sum_{j}{\left(\sum_{k} {m_{1ik} \times m_{2kj}\right)} \times v_j}
  &= \sum_{j}{\sum_{k} {m_{1ik} \times m_{2kj} \times v_j}} \\
  &= \sum_{k}{\sum_{j} {m_{1ik} \times m_{2kj} \times v_j}} \\
  &= \sum_{k}{m_{1ik} \times \sum_{k} {m_{1ik} \times m_{2kj} \times v_j}}
\end{align}
$$

Here are the gory details if you aren't happy postulating `lemma`:

```agda
            -- ‚â°‚ü® cong sum (fin-ext Œª j ‚Üí sum-scalar (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j) (v j))  ‚ü©
        -- sum (Œª j ‚Üí sum (Œª k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j * v j))
            -- ‚â°‚ü® sum-sum (Œª j k ‚Üí m‚ÇÅ i k * m‚ÇÇ k j * v j) ‚ü©
        -- sum (Œª k ‚Üí sum (Œª j ‚Üí m‚ÇÅ i k * m‚ÇÇ k j * v j))    ‚â°‚ü® obvious ‚ü©
        -- sum (Œª k ‚Üí sum (Œª j ‚Üí m‚ÇÅ i k * (m‚ÇÇ k j * v j)))  ‚â°‚ü® obvious ‚ü©

    sum-scalar : (f : Fin m ‚Üí X) ‚Üí (y : X) ‚Üí sum (Œª x ‚Üí f x) * y ‚â° sum (Œª x ‚Üí f x * y)
    sum-scalar {zero} f y = *-zeroÀ° y
    sum-scalar {suc m} f y =
      begin
        (f zero + sum (Œª x ‚Üí f (suc x))) * y
      ‚â°‚ü® *-+-distrib ≥ (f zero) _ y ‚ü©
        f zero * y + sum (Œª x ‚Üí f (suc x)) * y
      ‚â°‚ü® cong (f zero * y +_) (sum-scalar (f ‚àò suc) y) ‚ü©
        f zero * y + sum (Œª x ‚Üí f (suc x) * y)
      ‚àé
      where open ‚â°-Reasoning

    postulate
      obvious : {x y : X} ‚Üí x ‚â° y

    +-sum : (f‚ÇÅ f‚ÇÇ : Fin m ‚Üí X) ‚Üí sum f‚ÇÅ + sum f‚ÇÇ ‚â° sum (Œª x ‚Üí f‚ÇÅ x + f‚ÇÇ x)
    +-sum {zero} f‚ÇÅ f‚ÇÇ = +-identity ≥ 0#
    +-sum {suc m} f‚ÇÅ f‚ÇÇ =
      begin
        f‚ÇÅ zero + sum (Œª x ‚Üí f‚ÇÅ (suc x)) + (f‚ÇÇ zero + sum (Œª x ‚Üí f‚ÇÇ (suc x)))
      ‚â°‚ü® obvious ‚ü©
        f‚ÇÅ zero + f‚ÇÇ zero + (sum (Œª x ‚Üí f‚ÇÅ (suc x)) + sum (Œª x ‚Üí f‚ÇÇ (suc x)))
      ‚â°‚ü® cong (Œª œÜ ‚Üí f‚ÇÅ zero + f‚ÇÇ zero + œÜ) (+-sum (f‚ÇÅ ‚àò suc) (f‚ÇÇ ‚àò suc)) ‚ü©
        f‚ÇÅ zero + f‚ÇÇ zero + sum (Œª x ‚Üí f‚ÇÅ (suc x) + f‚ÇÇ (suc x))
      ‚àé
      where
        open ‚â°-Reasoning


    sum-sum : (f : Fin m ‚Üí Fin n ‚Üí X) ‚Üí sum (Œª j ‚Üí sum (Œª k ‚Üí f j k)) ‚â° sum (Œª k ‚Üí sum (Œª j ‚Üí f j k))
    sum-sum {zero} {zero} f = refl
    sum-sum {zero} {suc n} f = obvious
    sum-sum {suc m} {zero} f = obvious
    sum-sum {suc m} {suc n} f =
      begin
        sum {suc m} (Œª j ‚Üí sum {suc n} (Œª k ‚Üí f j k))
      ‚â°‚ü®‚ü©
        sum {suc n} (Œª k ‚Üí f zero k) + sum {m} (Œª j ‚Üí sum {suc n} (Œª k ‚Üí f (suc j) k))
      ‚â°‚ü® cong (Œª œÜ ‚Üí sum {suc n} (Œª k ‚Üí f zero k) + œÜ) (sum-sum (Œª j k ‚Üí f (suc j) k)) ‚ü©
        sum {suc n} (Œª k ‚Üí f zero k) + sum {suc n} (Œª k ‚Üí sum {m} (Œª j ‚Üí f (suc j) k))
      ‚â°‚ü® +-sum (Œª k ‚Üí f zero k) (Œª k ‚Üí sum {m} (Œª j ‚Üí f (suc j) k)) ‚ü©
        sum {suc n} (Œª k ‚Üí f zero k + sum {m} (Œª j ‚Üí f (suc j) k))
      ‚â°‚ü®‚ü©
        sum {suc n} (Œª k ‚Üí sum {suc m} (Œª j ‚Üí f j k))
      ‚àé
      where open ‚â°-Reasoning
```

So, what kind of functions are representable as matrices? As it happens, they
are precisely the *linear maps* --- that is, the two properties must hold:

```agda
    map : (X ‚Üí X) ‚Üí Vec m ‚Üí Vec m
    map f v i = f (v i)

    zip : (X ‚Üí X ‚Üí X) ‚Üí Vec m ‚Üí Vec m ‚Üí Vec m
    zip f v‚ÇÅ v‚ÇÇ i = f (v‚ÇÅ i) (v‚ÇÇ i)

    record LinearFunction (f : Vec m ‚Üí Vec n) : Set c where
      field
        additive : ‚àÄ v‚ÇÅ v‚ÇÇ ‚Üí f (zip _+_ v‚ÇÅ v‚ÇÇ) ‚âó zip _+_ (f v‚ÇÅ) (f v‚ÇÇ)
        homogeneity : ‚àÄ v x ‚Üí f (map (x *_) v) ‚âó map (x *_) (f v)
    open LinearFunction

    ‚åä‚åã-linear : (M : Matrix m n) ‚Üí LinearFunction ‚åä M ‚åã
    additive (‚åä‚åã-linear M) v‚ÇÅ v‚ÇÇ i =
      begin
        ‚åä M ‚åã (zip _+_ v‚ÇÅ v‚ÇÇ) i
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí M i j * (v‚ÇÅ j + v‚ÇÇ j))
      ‚â°‚ü® cong sum (fin-ext Œª j ‚Üí *-+-distribÀ° _ _ (M i j)) ‚ü©
        sum (Œª j ‚Üí M i j * v‚ÇÅ j + M i j * v‚ÇÇ j)
      ‚â°‚ü® sym (+-sum (Œª j ‚Üí M i j * v‚ÇÅ j) (Œª j ‚Üí M i j * v‚ÇÇ j)) ‚ü©
        sum (Œª j ‚Üí M i j * v‚ÇÅ j) + sum (Œª j ‚Üí M i j * v‚ÇÇ j)
      ‚â°‚ü®‚ü©
        ‚åä M ‚åã v‚ÇÅ i + ‚åä M ‚åã v‚ÇÇ i
      ‚àé
      where open ‚â°-Reasoning
    homogeneity (‚åä‚åã-linear M) v x i =
      begin
        ‚åä M ‚åã (map (x *_) v) i
      ‚â°‚ü®‚ü©
        sum (Œª j ‚Üí M i j * (x * v j))
      ‚â°‚ü® obvious ‚ü©
        sum (Œª j ‚Üí M i j * (v j * x))
      ‚â°‚ü® obvious ‚ü©
        sum (Œª j ‚Üí (M i j * v j) * x)
      ‚â°‚ü® obvious ‚ü©
        sum (Œª j ‚Üí (M i j * v j) * x)
      ‚â°‚ü® sym (sum-scalar (Œª j ‚Üí (M i j * v j)) x) ‚ü©
        sum (Œª j ‚Üí M i j * v j) * x
      ‚â°‚ü® *-comm _ x ‚ü©
        x * sum (Œª j ‚Üí M i j * v j)
      ‚â°‚ü®‚ü©
        map (x *_) (‚åä M ‚åã v) i
      ‚àé
      where open ‚â°-Reasoning
```

```agda

open import Data.Bool using (true; false)
open import Relation.Nullary using (Dec; yes; no; _because_; of ∏)

module dictionaries {K : Set} (_‚âü_ : (x y : K) ‚Üí Dec (x ‚â° y)) where
  open import Data.Maybe using (Maybe; just; nothing)
  open import Data.Product using (_√ó_; _,_; ‚àÉ; Œ£; proj‚ÇÅ; proj‚ÇÇ)

  open import Data.List using (List; []; _‚à∑_; map)
  open import Data.List.Relation.Unary.All using (All; []; _‚à∑_)
  open import Data.List.Relation.Unary.AllPairs using (AllPairs; []; _‚à∑_)
  open import Data.List.Relation.Unary.Unique.Propositional using (Unique; []; _‚à∑_)

  private variable
    V : Set

  UniqueAssocList : (K V : Set) ‚Üí List (K √ó V) ‚Üí Set
  UniqueAssocList _ _ = AllPairs Œª { (k‚ÇÅ , _) (k‚ÇÇ , _) ‚Üí k‚ÇÅ ‚â¢ k‚ÇÇ }

  Dict : Set ‚Üí Set ‚Üí Set
  Dict K V = ‚àÉ (UniqueAssocList K V)

  lookup : List (K √ó V) ‚Üí K ‚Üí Maybe V
  lookup [] i = nothing
  lookup ((k , v) ‚à∑ l) i with i ‚âü k
  ... | yes refl = just v
  ... | no _ = lookup l i

  ‚åä_‚åã : Dict K V ‚Üí (K ‚Üí Maybe V)
  ‚åä l , _ ‚åã = lookup l

  data Preimage_‚àã_ (f : K ‚Üí Maybe V) : K ‚Üí Set where
    im : ‚àÄ {x} y ‚Üí f x ‚â° just y ‚Üí Preimage f ‚àã x

  open import Data.List.Membership.Propositional

  record ComputablePreimage (f : K ‚Üí Maybe V) (l : List K) : Set where
    field
      is-unique : Unique l
      is-preimage : All (Preimage f ‚àã_) l
      is-total : ‚àÄ k v ‚Üí f k ‚â° just v ‚Üí k ‚àà l
  open ComputablePreimage

  preimage : Dict K V ‚Üí List K
  preimage (l , _) = map proj‚ÇÅ l

  open import Data.List.Relation.Unary.Unique.Propositional.Properties

  postulate
    ‚âü-refl : ‚àÄ k ‚Üí k ‚âü k ‚â° (true because of ∏ refl)

  open import Data.Empty using (‚ä•-elim)


--   ‚åä‚åã-preimage : (d : Dict K V) ‚Üí ComputablePreimage ‚åä d ‚åã (preimage d)
--   is-unique (‚åä‚åã-preimage (l , u)) = map‚Å∫ ? ?
--   is-preimage (‚åä‚åã-preimage ([] , _)) = []
--   is-preimage (‚åä‚åã-preimage d@((k , v) ‚à∑ l , _ ‚à∑ p)) with ‚åä d ‚åã k in eq
--   ... | just v rewrite eq = im v eq ‚à∑ is-preimage {! ‚åä‚åã-preimage (l , p) !}
--   ... | nothing = ‚ä•-elim {! !}
--   is-total (‚åä‚åã-preimage d) = {! !}

-- Fuck preimages.
```

subsets


