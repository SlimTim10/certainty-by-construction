# Functions, Big and Small

```agda
module functions where

open import Level using (Level)
```

Computer science is chocked full of data structures. A great many come from the
official pantheon---things like binary search trees, hash maps, stacks, graphs,
and heaps. But, dwarfing all of these, there exists orders of magnitude more
data structures in the arcane vault, from the
passingly-familiar-but-unlikely-to-have-implemented *rope* to the obscure *Judy
array.* With so many options to choose from, how can we even hope to make an
informed choice?

The reason there exist many more data structures than any practitioner can
possibly know about is that most data structures are minor tweaks of other
well-known structures. For example, the UB-tree is a variation on the B+ tree,
which itself is a B-tree that maintains a particular invariant, while a B-tree
is a generalization of the binary search tree (BST henceforth). Unrolling the
lineage here shows us that whatever the UB-tree is, it's probably a BST that has
more desirable computational properties for certain shapes of data.

As Donald Knuth said, "premature optimization is the root of all evil." For the
vast majority of tasks, you can start with (and subsequently get away with) a
BST, upgrading to the more complex UB-tree in the future only if it turns out to
be mission critical. This is a well-understood idea in the modern age.

However, most programmers coming to Agda make an error in the spirit of the
Co-Blub paradox. After years of honing their taste and cutting their teeth on
picking the simplest data structure for the job, they come to Agda and
immediately fall down the rabbit-hole of long, arduous proofs. As I have gotten
older and more experienced, my guiding philosophy for writing software has
become *if it feels too hard, it probably is.*

As it happens, your choice of representation matters much more in Agda than it
does in most programming languages. That arises from the fact that your proofs
will inevitably trace the same grooves as the implementations they are proofs
*about.* In other words, the proof follows the implementation. It's not hard to
imagine that a complicated implementation will warrant a complicated proof.


## Matrices

Let's work through an example together, to get a feel for just how important a
representation can be. Our object of investigation will be *matrices*---that is,
rectangular arrays of numbers. Matrices are often used in computational
geometry, including 3D graphics, and are the back-bone of modern machine
learning techniques. As an exercise in honing our
translating-mathematics-to-Agda chops, let's take a look at the definition of a
matrix.

Matrix
:   A rectangular array of numbers.

Matrices have a predefined height and width, often referred to as $m$ and $n$
respectively, and given in that order. For example, the following is a 3x2
matrix:

```text
1   1
5  -42
0  2.5
```

Note that the numbers inside a matrix are rather flexible. Depending on the
circumstances, we might prefer them to be naturals, while in others we might
want reals, or even functions. In order to avoid the complexities here, we will
simply parameterize the our module over the type of numbers, and postulate any
properties of those numbers as the need occurs. Let's call this number type
parameter `ùî∏`:

```agda
module matrix-induction {ùî∏ : Set} where
```


### The Row-Major Representation

Returning to the problem of modeling matrices in Agda, note that we don't have
any good, inductive primitives for two-dimensional data, I think most
programmers would thus come up with the next best thing: the "vector of vectors"
model---indeed, it's what I first thought of.

```agda
  open import Data.Product
    as Œ£
    using (_√ó_; _,_)
  open import Data.Nat
    using (‚Ñï; zero; suc)
  open import Data.Vec
    using (Vec; []; _‚à∑_)

  Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
  Matrix m n = Vec (Vec ùî∏ n) m

  private variable
    m n p : ‚Ñï
```

This representation is known as the "row-major order" of matrices, that is, the
rows have contiguous data, while the columns do not. There are immediate
repercussions here. For example, let's implement the function `top/rest` which
separates the first row from the rest of the matrix:

```agda
  top/rest
      : Matrix (suc m) n
      ‚Üí Vec ùî∏ n √ó Matrix m n
  top/rest (x ‚à∑ xs) = x , xs
```

Compare `top/rest` to the analogous function that pulls the leftmost column off
of a matrix:

```agda
  left/rest
      : Matrix m (suc n)
      ‚Üí Vec ùî∏ m √ó Matrix m n
  left/rest [] = [] , []
  left/rest ((x ‚à∑ v) ‚à∑ m)
    = Œ£.map (x ‚à∑_) (v ‚à∑_) (left/rest m)
```

The dramatic difference in complexity between these two analogous functions is
telling. Clearly, row-major order significantly privileges working with rows
over working with columns.

Nevertheless, we can continue by implementing a few special matrices of note.
First is the zero-matrix, which is the matrix that is full only of zeroes. Note
that we will also need to postulate the existence of `0# : ùî∏`.

```agda
  postulate 0# : ùî∏

  open Data.Vec
    using (replicate)

  0‚Çò : Matrix m n
  0‚Çò = replicate (replicate 0#)
```

Two matrices of the same dimensions support a kind of addition, given by adding
the respective cells in each of the two columns. That is:

$$
\begin{bmatrix}
a & b & c\\
d & e & f
\end{bmatrix}
+
\begin{bmatrix}
x & y & z\\
t & u & v
\end{bmatrix}
=
\begin{bmatrix}
a + x & b + y & c + z\\
d + t & e + u & f + v
\end{bmatrix}
$$

We can implement this operation over matrices by positing the existence of an
addition over `ùî∏`, as well as some common-sense identity laws:

```agda
  open import Relation.Binary.PropositionalEquality

  postulate
    _+_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏
    +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x
    +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x

  open Data.Vec
    using (zipWith)
```

Addition of matrices doesn't present us any problems, as pointwise operations
don't need to distinguish between rows and columns. Thus, we can zip the rows
together, zip the corresponding cells together, and add each pair:

```agda
  _+‚Çò_ : Matrix m n ‚Üí Matrix m n ‚Üí Matrix m n
  x +‚Çò y = zipWith (zipWith _+_) x y
```

Let's now prove the trivial fact that `0‚Çò` is a left identity for `+‚Çò`:

```agda
  +‚Çò-identityÀ° : (x : Matrix m n) ‚Üí 0‚Çò +‚Çò x ‚â° x
```

We can begin, as always, with induction on our argument. The first case, in
which `m ‚â° 0`, is easy:

```agda
  +‚Çò-identityÀ° [] = refl
```

The case that `n ‚â° 0` is also easy, although slightly more work, as our
row-major order would suggest:

```agda
  +‚Çò-identityÀ° ([] ‚à∑ rs)
    rewrite +‚Çò-identityÀ° rs
      = refl
```

We're now left with the induction case. After some obvious rewriting to
eliminate the `0# +_` and the row-recursive case, we're left here:

```agda
  +‚Çò-identityÀ° ((c ‚à∑ cs) ‚à∑ rs)
    rewrite +-identityÀ° c
    rewrite +‚Çò-identityÀ° rs
```

with the goal

```goal
  (c ‚à∑ zipWith _+_ (replicate 0#) cs) ‚à∑ rs
‚â°
  (c ‚à∑ cs) ‚à∑ rs
```

and it's unclear how to move forwards. It would be nice if our induction just
worked, but, unfortunately, it doesn't. Crossing our fingers that this is not a
serious problem, we can write a little lemma to solve the goal for us:

```agda
      = cong (Œª œÜ ‚Üí (c ‚à∑ œÜ) ‚à∑ rs) (lemma cs)

    where
      lemma
          : ‚àÄ {m} (cs : Vec ùî∏ m)
          ‚Üí zipWith _+_ (replicate 0#) cs ‚â° cs
      lemma [] = refl
      lemma (c ‚à∑ cs)
        rewrite +-identityÀ° c
        rewrite lemma cs
          = refl
```

It's not the tidiest proof in the world, but it certainly gets the job done.
However, we should be wary here; this is our second function in which dealing
with the columns was clunkier than the same operation over the rows.

Addition, however, is not the primary task for which programmers and
mathematicians use matrices. No, the more interesting operation is *matrix
multiplication.* Matrix multiplication, unlike your everyday multiplication, has
a stronger type, and requires our two matrices to have an equal dimension
between them. That is, the matrix on the left must have the same width as the
height of the matrix on the right. That is, given `a : Matrix m n` and `b :
Matrix n p`, we can write the operation `a *‚Çò b` in symbols as:

$$
\begin{bmatrix}
a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\
a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\
\vdots & \vdots & \ddots & \vdots \\
a_{m,1} & a_{m,2} & \cdots & a_{m,n}
\end{bmatrix}
\times
\begin{bmatrix}
b_{1,1} & b_{1,2} & \cdots & b_{1,p}\\
b_{2,1} & b_{2,2} & \cdots & b_{2,p}\\
\vdots & \vdots & \ddots & \vdots \\
b_{n,1} & b_{n,2} & \cdots & b_{n,p}
\end{bmatrix}
$$

with the result being `c : Matrix m p`, where each cell is given by the formula:

$$
c_{i,j} = \sum_{k = 1}^{n} a_{i,k} \times b_{k, j}
$$

Said another way, the product matrix resulting from a multiplication pairs the
rows of the first matrix with the columns of the second, adding each cell up
pointwise.

If this is your first time seeing matrix multiplication (or even if it isn't,)
it might be unclear what the *intuition* behind matrix multiplication is. Why
does it exist, what does it do, and why should we care about it? We will return
to this question in a moment, but for the time being, resign ourselves to
implementing it in our row-major matrix representation.

We will implement matrix multiplication in two steps; first, by computing the
*outer-product*, which is the analogous operation on vectors (matrices with one
dimension set to 1.) The outer product of two vectors is a matrix using the
length of the first as its height, and the length of the second as its width. In
symbols, the result of:

$$
\begin{bmatrix}
a_{1} \\
a_{2} \\
\vdots \
a_{m}
\end{bmatrix}
\otimes
\begin{bmatrix}
b_{1} \\
b_{2} \\
\vdots \
b_{n}
\end{bmatrix}
$$

is a matrix:

$$
\begin{bmatrix}
a_{1}\times b_{1} & a_{1}\times b_{2} & \cdots & a_{1}\times b_{n}\\
a_{2}\times b_{1} & a_{2}\times b_{2} & \cdots & a_{2}\times b_{n}\\
\vdots & \vdots & \ddots & \vdots \\
a_{m}\times b_{1} & a_{m}\times b_{2} & \cdots & a_{m}\times b_{n}
\end{bmatrix}
$$

It's not too tricky to implement such a thing in Agda; the secret is to write
down the type and use the type-checker to help us ensure that we haven't lost a
case anywhere.

```agda
  open Data.Vec
    using (map)

  postulate
    _*_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏

  _‚äó_ : Vec ùî∏ m ‚Üí Vec ùî∏ n ‚Üí Matrix m n
  []       ‚äó ys = []
  (x ‚à∑ xs) ‚äó ys = map (x *_) ys ‚à∑ xs ‚äó ys
```

Now that we have the outer product, we can implement matrix multiplication by
taking the outer product of each row/column pair and doing a matrix addition
with the multiplication of the rest of the matrix. Start with the type:

```agda
  _*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p
```

Recall that in the definition of matrix multiplication, the *columns* of the
first matrix get paired with the *rows* of the latter. Since our matrices are in
row-major order, our induction naturally will proceed on the second argument,
since that's where the rows are. If we're out of rows, the result is
conceptually zero, but that doesn't typecheck, so instead we use `0‚Çò` which is
the matrix analogue:

```agda
  x *‚Çò [] = 0‚Çò
```

Otherwise, we must pair a column from `x` with the row we just pulled off. We
can use `left/rest` to get the column, and then proceed with our outer product
added to the resultant multiplication:

```agda
  x *‚Çò (r ‚à∑ rs) =
    let c , cs = left/rest x
      in (c ‚äó r) +‚Çò (cs *‚Çò rs)
```

As it happens, this definition of `_*‚Çò_` *is* indeed correct, but it's rather
hard to convince ourselves of that, isn't it? Recall the definition we gave
earlier, where the $c_{i,j}$ element in the resultant matrix was given by the
formula:

$$
c_{i,j} = \sum_{k = 1}^{n} a_{i,k} \times b_{k, j}
$$

Our implementation instead gives us a recursive definition:

$$
a \times_m b = (a_{-, 1} \otimes b_{1, -}) +_m ((a_{-, 2\dots}) \times_m (b_{2\dots, -}))
$$

which uses nonstandard notation to suggest pulling a column off a matrix via
$a_{-, 1}$ and the rest of the matrix as $a_{-, 2\dots}$. We can convince
ourselves of the correctness here by noticing that the induction is actually on
`p`, which means the rows and the columns on which we're doing the outer product
remain of length `m` and `n` respectively. Thus, each outer product still
results in a matrix of size $m \times n$, of which we add up exactly `p` in
number. Thus, our definition here performs `p` matrix additions, while the
mathematical definition performs `p` scalar additions in each cell.

These two definitions are thus equivalent, but there is significantly more
algebraic manipulation necessary to use `_*‚Çò_` as written. Notice that if we
wanted to prove anything about it, we would first need to inline the definitions
of `left/rest`, `_‚äó_`, and `_+‚Çò_`, each of which is annoyingly recursive and
none of which will Agda automatically compute for us. It's thus rather more work
than we'd like to do! In choosing the row-major order as our representation,
we've obscured the mathematics we're trying to prove. Not only do we need to
still do the original mathematics, we also need to juggle the weight of our
representation.


### Function Representation

Rather than go forward with the row-major representation, we will try again with
a different representation and see how all the same things roll-out. We note
that where things really went wrong was that rows and columns were citizens of
differing standing. It was easy to work with rows, but difficult to work with
columns. Of course, we could always try a column-major ordering instead, but
that would merely move the challenges.

Instead, we find ourselves looking for a representation which doesn't make any
distinctions between the two dimensions. Any sort of inductive definition is
sure to build up matrices from smaller matrices, which is likely to give rise to
the same issues. Let's thus turn our attention to a function representation:

```agda
module matrix-functions {ùî∏ : Set} where
  open import Data.Nat
    using (‚Ñï; zero; suc)
  open import Data.Fin
    using (Fin; zero; suc)

  Matrix : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
  Matrix m n = (i : Fin m) ‚Üí (j : Fin n) ‚Üí ùî∏
```

A matrix is thus parameterized by its dimensions, and is represented by a
function which takes those indices and gives you back an element of `ùî∏`. Giving
names to the `Fin` arguments here isn't strictly necessary, but it helps Agda
give meaningful names to indices as we work with matrices.

We can implement the zero matrix trivially, by simply ignoring the indices:

```agda
  private variable
    m n p : ‚Ñï

  postulate 0# : ùî∏

  0‚Çò : Matrix m n
  0‚Çò _ _ = 0#
```

Furthermore, we can now implement the identity matrix straightforwardly. In
symbols, the identity function is a square ($n \times n$) matrix whose cells are
given by:

$$
c_{i,j} =
\begin{cases}
  1 & i = j \\
  0 & \text{otherwise}
\end{cases}
$$

In Agda:

```agda
  open import Data.Bool
    using (Bool; true; false; if_then_else_)

  infix 3 _==_
  _==_ : Fin n ‚Üí Fin n ‚Üí Bool
  zero == zero = true
  zero == suc y = false
  suc x == zero = false
  suc x == suc y = x == y

  postulate 1# : ùî∏

  1‚Çò : Matrix m m
  1‚Çò i j = if i == j then 1# else 0#
```

We can implement the summation operator by way of `sum`, which takes a function
out of `Fin n` and adds up every term:

```agda
  postulate
    _+_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏

  open import Function
    using (id; _‚àò_)

  sum : (Fin n ‚Üí ùî∏) ‚Üí ùî∏
  sum {zero} v = 0#
  sum {suc n} v = v zero + sum {n} (v ‚àò suc)
```

With all of these pieces under our belt, the definition of matrix multiplication
is now extremely simple, and mirrors its mathematical counterpart exactly:

```agda
  postulate
    _*_ : ùî∏ ‚Üí ùî∏ ‚Üí ùî∏

  _*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p
  (a *‚Çò b) i j = sum Œª k ‚Üí a i k * b k j
```

Implementing matrix addition is also exceptionally easy under our new scheme,
corresponding again exactly with the mathematical definition:

```agda
  _+‚Çò_ : Matrix m n ‚Üí Matrix m n ‚Üí Matrix m n
  (a +‚Çò b) i j = a i j + b i j
```

With a little bit of machinery in order to express equality of matrices:

```agda
  open import Relation.Binary.PropositionalEquality

  infix 0 _‚â°‚Çò_
  _‚â°‚Çò_ : (a b : Matrix m n) ‚Üí Set
  a ‚â°‚Çò b = ‚àÄ i j ‚Üí a i j ‚â° b i j
```

We can now prove `+‚Çò-identityÀ°` again.

```agda
  postulate
    +-identityÀ° : ‚àÄ x ‚Üí 0# + x ‚â° x

  +‚Çò-identityÀ° : (a : Matrix m n) ‚Üí 0‚Çò +‚Çò a ‚â°‚Çò a
  +‚Çò-identityÀ° a i j
    rewrite +-identityÀ° (a i j)
      = refl
```

Compare the simplicity of this proof to the previous one we wrote for the
row-major implementation:

```agda
--  +‚Çò-identityÀ° ([] ‚à∑ rs)
--    rewrite +‚Çò-identityÀ° rs
--      = refl
--  +‚Çò-identityÀ° ((c ‚à∑ cs) ‚à∑ rs)
--    rewrite +-identityÀ° c
--    rewrite +‚Çò-identityÀ° rs
--      = cong (Œª œÜ ‚Üí (c ‚à∑ œÜ) ‚à∑ rs) (lemma cs)
--    where
--      lemma
--          : ‚àÄ {m} (cs : Vec ùî∏ m)
--          ‚Üí zipWith _+_ (replicate 0#) cs ‚â° cs
--      lemma [] = refl
--      lemma (c ‚à∑ cs)
--        rewrite +-identityÀ° c
--        rewrite lemma cs
--          = refl
```

Clearly we are onto something with our new representation. A problem which once
was hard is now much easier. Content with our new representation, we can explore
the question of what *is* a matrix, and why do practitioners care so much about
them.


### Matrices as Functions

The type of `_*‚Çò_ : Matrix m n ‚Üí Matrix n p ‚Üí Matrix m p` is somewhat suspicious
in its requirement that both matrices have a `n` dimension, in different
positions, which gets eliminated being pushed through the multiplication.
Compare this type against that of function composition, namely `_‚àò_ : (B ‚Üí C) ‚Üí
(A ‚Üí B) ‚Üí (A ‚Üí C)`, which seems oddly similar: the functions both need a `B`
parameter, on opposite sides of the arrow, which gets eliminated in the result.

This is not a coincidence, because nothing is ever a coincidence. Whenever the
indices need to align, you should immediately think "function" (or at least
"morphism," as we will discuss in @sec:categorytheory.) But, if matrices
correspond to functions, exactly which functions are we talking about? The
indices give us a clue --- the input must be parameterized by exactly one of
`m`, `n`, and the output must be the other. In every day tasks, matrices are
usually multiplied against column vectors. For example, if we think about a
2-dimensional space with XY coordinates, the corresponds to a 90 degree
rotation clockwise:

$$
\begin{bmatrix}
0 & -1\\
1 & 0
\end{bmatrix}
$$

We can thus apply this matrix to a particular coordinate, let's say $(5, 6)$, as
follows:

$$
\begin{bmatrix}
0 & -1\\
1 & 0
\end{bmatrix}
\times
\begin{bmatrix}
5 \\
6
\end{bmatrix}
$$

Viewed in this light, the XY coordinate is the input, the rotation matrix is the
function, and the result of the multiplication is the output. Thus, it seems
natural to call the "width" of the matrix its input index. Let's define the type
of vectors as functions into our scalar:

```agda
  Vec : ‚Ñï ‚Üí Set
  Vec n = Fin n ‚Üí ùî∏
```

Nothing goes particularly wrong if we were to use the standard `Data.Vec`
encoding instead, but this saves us some lemmas to more naturally turn vectors
into matrices and vice versa. Given vectors, we can lift them into column
matrices:

```agda
  column : Vec m ‚Üí Matrix m 1
  column v i _ = v i
```

which gives rise to a natural definition of the interpretation of a matrix as a
function from vectors to vectors:

```agda
  ‚åä_‚åã : Matrix m n ‚Üí Vec n ‚Üí Vec m
  ‚åä M ‚åã v i = (M *‚Çò column v) i zero
```

This is merely a convention; nothing prevents us from multiplying on the left
instead. In fact, we will prove this fact later (see `·µÄ-*‚Çò-braid`.) For the time
being, we'd like to prove that function composition is indeed a specification
for `_*‚Çò_`. That is, we'd like to work our way towards a proof of `‚åä*‚Çò‚åã‚ü∂‚åä‚åã‚àò‚åä‚åã :
(g : Matrix m n) ‚Üí (f : Matrix n p) ‚Üí ‚àÄ v ‚Üí ‚åä g *‚Çò f ‚åã v ‚âó (‚åä g ‚åã ‚àò ‚åä f ‚åã) v`.
It's a bit of a mouthful, but really what we're saying here is that the
interpretation of matrix multiplication is the composition of the matrices
interpreted as functions.

We will build our way towards this proof, but as a helper lemma, it will be
valuable to show the extensionality of sum---that is, if we can show the
equivalence of each term in the sum, we can thus show the two sums themselves
are equal. This function requires a little bit of induction on the `Fin`ite
numbers, but is a straightforward application of rewriting:

```agda
  sum-ext
      : {f g : Fin m ‚Üí ùî∏}
      ‚Üí f ‚âó g
      ‚Üí sum f ‚â° sum g
  sum-ext {zero} x = refl
  sum-ext {suc m} same
    rewrite same zero
    rewrite sum-ext (same ‚àò suc)
      = refl
```

Our next lemma is to show that multiplication distributes over `sum`. This is a
straightforward application of the fact that multiplication distributes over
addition; only, we need to repeat the argument for every term in the sum. We
assume two non-controversial facts about `ùî∏`:

```agda
  postulate
    *-zeroÀ° : ‚àÄ x ‚Üí 0# * x ‚â° 0#
    *-+-distrib ≥ : ‚àÄ x y z ‚Üí (x + y) * z ‚â° (x * z) + (y * z)
```

and then can show `*-sum-distrib ≥` in earnest:

```agda
  *-sum-distrib ≥
    : {f : Fin m ‚Üí ùî∏}
    ‚Üí (k : ùî∏)
    ‚Üí sum f * k ‚â° sum (Œª i ‚Üí f i * k)
  *-sum-distrib ≥ {zero} k = *-zeroÀ° k
  *-sum-distrib ≥ {suc m} {f} k
    rewrite *-+-distrib ≥ (f zero) (sum (f ‚àò suc)) k
    rewrite *-sum-distrib ≥ {f = f ‚àò suc} k
      = refl

  sum-zero : sum {m} (Œª _ ‚Üí 0#) ‚â° 0#
  sum-zero {zero} = refl
  sum-zero {suc m}
    rewrite sum-zero {m}
      = +-identityÀ° 0#
```

There are a few more facts to prove about sums before we can get to the meat of
our proof. But first, another reasonable assumption about `ùî∏` --- namely that
it's multiplication is commutative:

```agda
  postulate
    *-comm : ‚àÄ x y ‚Üí x * y ‚â° y * x
```

and, for the sake of the reader's (and the author's) sanity, we will postulate
`‚Ä¶algebra‚Ä¶` stating that the intermediary step is a tedious-but-straightforward
application of grade-school algebra:

```agda
    ‚Ä¶algebra‚Ä¶ : {‚Ñì : Level} {A : Set ‚Ñì} {x y : A} ‚Üí x ‚â° y
```

Returning to our final two lemmas: first, we can show that the sum of two `sum`s
over the same bounds is the `sum` of the sum.

```agda
  +-sum-hom
    : (f g : Fin m ‚Üí ùî∏)
    ‚Üí sum f + sum g ‚â° sum (Œª i ‚Üí f i + g i)
```

The proof of this is rather verbose, but is just some shuffling of the addition
terms and a recursive call:

```agda
  +-sum-hom {zero} f g = +-identityÀ° 0#
  +-sum-hom {suc m} f g = begin
      (f zero + sum (f ‚àò suc)) + (g zero + sum (g ‚àò suc))
    ‚â°‚ü® ‚Ä¶algebra‚Ä¶ ‚ü©
      (f zero + g zero) + (sum (f ‚àò suc) + sum (g ‚àò suc))
    ‚â°‚ü® cong ((f zero + g zero) +_)
            (+-sum-hom (f ‚àò suc) (g ‚àò suc)) ‚ü©
      (f zero + g zero) + sum (Œª i ‚Üí f (suc i) + g (suc i))
    ‚àé
    where open ‚â°-Reasoning
```

Our final necessary lemma before showing that matrix multiplication is a model
for function composition is to show that we can arbitrarily swap nested `sum`s,
so long as doing so doesn't introduce any scoping issues. The idea is that,
given some function `f : Fin m ‚Üí Fin n ‚Üí ùî∏`, we can freely interchange nested
`sum`s which iterate over `m` and `n`. First, the type:

```agda
  postulate
    *-zero ≥ : ‚àÄ x ‚Üí x * 0# ‚â° 0#

  -- TODO(sandy): write some prose about this, pull from above, fix it
  sum-0 : sum {m} (Œª k ‚Üí 0#) ‚â° 0#
  sum-0 = begin
    sum (Œª k ‚Üí 0#)       ‚â°‚ü® sym (sum-ext (Œª _ ‚Üí *-zeroÀ° 0#)) ‚ü©
    sum (Œª k ‚Üí 0# * 0#)  ‚â°‚ü® sym (*-sum-distrib ≥ 0#) ‚ü©
    sum (Œª k ‚Üí 0#) * 0#  ‚â°‚ü® *-zero ≥ _ ‚ü©
    0#                   ‚àé
    where open ‚â°-Reasoning
```

```agda
  sum-sum-distrib
      : (f : Fin m ‚Üí Fin n ‚Üí ùî∏)
      ‚Üí sum (Œª j ‚Üí sum (Œª k ‚Üí f j k))
      ‚â° sum (Œª k ‚Üí sum (Œª j ‚Üí f j k))
```

Take a moment to really understand what's going on in this type signature before
continuing. The only difference in the terms we'd like to show equivalence of is
which `sum` binds `j` and which binds `k`. We can proceed by induction on `m`,
which first requires us to show the sum of many 0 terms is itself zero:

```agda
  sum-sum-distrib {zero} {n} f = sym (sum-0)
```

The inductive case isn't particularly interesting, we just need to get
everything into the right shape that we can invoke `sum-sum-distrib`:

```agda
  sum-sum-distrib {suc m} {n} f =
    begin
      sum (Œª k ‚Üí f zero k) + sum (Œª j ‚Üí sum (Œª k ‚Üí f (suc j) k))
    ‚â°‚ü® cong (sum _ +_) (sum-sum-distrib (Œª j ‚Üí f (suc j))) ‚ü©
      sum (Œª k ‚Üí f zero k) + sum (Œª k ‚Üí sum (Œª j ‚Üí f (suc j) k))
    ‚â°‚ü® +-sum-hom _ _ ‚ü©
      sum (Œª k ‚Üí f zero k + sum (Œª j ‚Üí f (suc j) k))
    ‚àé
    where open ‚â°-Reasoning
```

Finally we get to the meat of our goal: to show that the interpretation of
matrix multiplication is the composition of the interpretation of matrices as
functions. Start with the type:

```agda
  ‚åä*‚Çò‚åã‚ü∂‚åä‚åã‚àò‚åä‚åã
    : (g : Matrix m n)
    ‚Üí (f : Matrix n p)
    ‚Üí (v : Fin p ‚Üí ùî∏)
    ‚Üí ‚åä g *‚Çò f ‚åã v ‚âó (‚åä g ‚åã ‚àò ‚åä f ‚åã) v
```

The proof mostly writes itself, given the lemmas we've already proven. Of
course, if you were working this out for yourself, you'd start with `‚åä*‚Çò‚åã‚ü∂‚åä‚åã‚àò‚åä‚åã`
and work backwards, determining which lemmas you need and proving them. This is
one flaw of presenting a book as a literate Agda document; it's hard to show
things in the order they happen "in real life."

```agda
  ‚åä*‚Çò‚åã‚ü∂‚åä‚åã‚àò‚åä‚åã g f v i = begin
      sum (Œª j ‚Üí sum (Œª k ‚Üí g i k * f k j) * v j)
    ‚â°‚ü® sum-ext (Œª j ‚Üí *-sum-distrib ≥ (v j))  ‚ü©
      sum (Œª j ‚Üí sum (Œª k ‚Üí (g i k * f k j) * v j))
    ‚â°‚ü® sum-sum-distrib (Œª j k ‚Üí (g i k * f k j) * v j) ‚ü©
      sum (Œª k ‚Üí sum (Œª j ‚Üí (g i k * f k j) * v j))
    ‚â°‚ü® ‚Ä¶algebra‚Ä¶ ‚ü©
      sum (Œª k ‚Üí sum (Œª j ‚Üí (f k j * v j) * g i k))
    ‚â°‚ü® sym (sum-ext (Œª k ‚Üí *-sum-distrib ≥ (g i k))) ‚ü©
      sum (Œª k ‚Üí sum (Œª j ‚Üí f k j * v j) * g i k)
    ‚â°‚ü® sum-ext (Œª k ‚Üí *-comm _ _) ‚ü©
      sum (Œª k ‚Üí g i k * sum (Œª j ‚Üí f k j * v j))
    ‚àé
    where open ‚â°-Reasoning
```

As a nice sanity check, we would like it if `‚åä 1‚Çò ‚åã` were the `id` function. So
let's show it!

```agda
  postulate
    *-identityÀ° : ‚àÄ x ‚Üí 1# * x ‚â° x
    +-identity ≥ : ‚àÄ x ‚Üí x + 0# ‚â° x

  ‚åä1‚Çò‚åã : ‚àÄ v ‚Üí ‚åä 1‚Çò {m} ‚åã v ‚âó v
  ‚åä1‚Çò‚åã {suc m} v zero
    rewrite *-identityÀ° (v zero)
    rewrite sum-ext (Œª x ‚Üí *-zeroÀ° (v (suc x)))
    rewrite sum-0 {m}
    rewrite +-identity ≥ (v zero)
      = refl
  ‚åä1‚Çò‚åã v (suc x)
    rewrite *-zeroÀ° (v zero)
    rewrite ‚åä1‚Çò‚åã (v ‚àò suc) x
      = +-identityÀ° _
```

Let's return now to the question of whether we made a bad choice when defining
our interpretation as multiplication on the right by a column vector. To
contrast, we can implement `‚åä_‚åã‚Ä≤`, which performs multiplication on the left
with a row vector:

```agda
  row : (Fin n ‚Üí ùî∏) ‚Üí Matrix 1 n
  row v _ j = v j

  ‚åä_‚åã‚Ä≤ : Matrix m n ‚Üí Vec m ‚Üí Vec n
  ‚åä M ‚åã‚Ä≤ v i = (row v *‚Çò M) zero i
```

My claim is that we don't need `‚åä_‚åã‚Ä≤`; instead, we can simply use `‚åä_‚åã` with the
*transpose* of the matrix. The transpose swaps a matrix's width for its height,
and vice versa:

```agda
  infix 100 _·µÄ
  _·µÄ : Matrix m n ‚Üí Matrix n m
  (M ·µÄ) i j = M j i
```

It's trivial now to show that `‚åä_‚åã'` is nothing more than `‚åä_‚åã ‚àò _·µÄ` --- that
is, the interpretation of the transpose of the original matrix! The proof
depends only on the commutativity of multiplication, which makes sense when you
think about what these two operations must be doing:

```agda
  ‚åä‚åã‚Ä≤-is-‚åä·µÄ‚åã
      : (a : Matrix m n)
      ‚Üí (v : Vec m)
      ‚Üí ‚åä a ‚åã‚Ä≤ v ‚âó ‚åä a ·µÄ ‚åã v
  ‚åä‚åã‚Ä≤-is-‚åä·µÄ‚åã a v x = sum-ext Œª k ‚Üí *-comm _ _

  ‚åäg·µÄ‚àòf·µÄ‚åã-‚åäf‚àòg‚åã·µÄ
      : (g : Matrix n m)
     ‚Üí  (f : Matrix p n)
      ‚Üí g ·µÄ *‚Çò f ·µÄ ‚â°‚Çò (f *‚Çò g) ·µÄ
  ‚åäg·µÄ‚àòf·µÄ‚åã-‚åäf‚àòg‚åã·µÄ g f i j = sum-ext Œª _ ‚Üí *-comm _ _
```

Because of `‚åä‚åã‚Ä≤-is-‚åä·µÄ‚åã`, we are able to make the arbitrary decision to multiply
on the right without any loss of generalization. Anyone who thinks we've made
the wrong decision is welcome to transpose their matrix first.



So, what kind of functions are representable as matrices? As it happens, they
are precisely the *linear maps* --- that is, the two properties must hold:

```agda
  map : (ùî∏ ‚Üí ùî∏) ‚Üí Vec m ‚Üí Vec m
  map f v i = f (v i)

  zip : (ùî∏ ‚Üí ùî∏ ‚Üí ùî∏) ‚Üí Vec m ‚Üí Vec m ‚Üí Vec m
  zip f v‚ÇÅ v‚ÇÇ i = f (v‚ÇÅ i) (v‚ÇÇ i)

  record LinearFunction (f : Vec m ‚Üí Vec n) : Set where
    constructor _‚ä¢_
    field
      additive
          : ‚àÄ v‚ÇÅ v‚ÇÇ
          ‚Üí f (zip _+_ v‚ÇÅ v‚ÇÇ) ‚âó zip _+_ (f v‚ÇÅ) (f v‚ÇÇ)
      homogeneity
          : ‚àÄ v x
          ‚Üí f (map (x *_) v) ‚âó map (x *_) (f v)
  open LinearFunction

  open import Data.Product
    using (Œ£; proj‚ÇÅ; proj‚ÇÇ)

  ‚åà_‚åâ : {f : Vec n ‚Üí Vec m} ‚Üí LinearFunction f ‚Üí Matrix m n
  ‚åà_‚åâ {f = f} _ i j = f (1‚Çò j) i

  postulate
    vec-ext : {f g : Vec m} ‚Üí (‚àÄ i ‚Üí f i ‚â° g i) ‚Üí f ‚â° g
    *-identity ≥ : ‚àÄ x ‚Üí x * 1# ‚â° x
    matrix-ext : {f g : Matrix m n} ‚Üí f ‚â°‚Çò g ‚Üí f ‚â° g

--   _*·µ•_ : ùî∏ ‚Üí Vec m ‚Üí Vec m
--   a *·µ• v = map (a *_) v

--   basis-sum : (v : Vec m) ‚Üí Vec m
--   basis-sum v x = sum Œª { k ‚Üí (v k *·µ• 1‚Çò k) x }

--   v-is-basis : (v : Vec m) ‚Üí basis-sum v ‚âó v
--   v-is-basis {suc m} v zero
--     rewrite *-identity ≥ (v zero)
--     rewrite sum-ext (Œª k ‚Üí *-zero ≥ (v (suc k)))
--     rewrite sum-zero {m}
--       = +-identity ≥ (v zero)
--   v-is-basis v (suc x)
--     rewrite *-zero ≥ (v zero)
--     rewrite v-is-basis (v ‚àò suc) x
--     rewrite +-identityÀ° (v (suc x))
--       = refl


  raise : Vec m ‚Üí Vec (suc m)
  raise v zero = 0#
  raise v (suc i) = v i

  +-raise-hom
      : ‚àÄ v‚ÇÅ v‚ÇÇ x
      ‚Üí raise {m} (Œª i ‚Üí v‚ÇÅ i + v‚ÇÇ i) x ‚â° raise v‚ÇÅ x + raise v‚ÇÇ x
  +-raise-hom v‚ÇÅ v‚ÇÇ zero rewrite +-identity ≥ 0# = refl
  +-raise-hom v‚ÇÅ v‚ÇÇ (suc x) = refl

  *-raise-hom
      : ‚àÄ v x ‚Üí raise {m} (map (x *_) v) ‚âó map (x *_) (raise v)
  *-raise-hom v x zero
    rewrite *-zero ≥ x = refl
  *-raise-hom v x (suc i) = refl

  linear-raise
      : {f : Vec (suc m) ‚Üí Vec n}
      ‚Üí LinearFunction f
      ‚Üí LinearFunction (Œª i j ‚Üí f (raise i) j)
  additive (linear-raise {f = f} (add ‚ä¢ _)) v‚ÇÅ v‚ÇÇ x =
    begin
      f (raise (Œª i ‚Üí v‚ÇÅ i + v‚ÇÇ i)) x
    ‚â°‚ü® cong (Œª œÜ ‚Üí f œÜ x) (vec-ext (+-raise-hom v‚ÇÅ v‚ÇÇ)) ‚ü©
      f (Œª i ‚Üí raise v‚ÇÅ i + raise v‚ÇÇ i) x
    ‚â°‚ü® add _ _ x ‚ü©
      f (raise v‚ÇÅ) x + f (raise v‚ÇÇ) x
    ‚àé
    where open ‚â°-Reasoning
  homogeneity (linear-raise {f = f} (_ ‚ä¢ hom)) v x i =
    begin
      f (raise (map (_*_ x) v)) i
    ‚â°‚ü® cong (Œª œÜ ‚Üí f œÜ i) (vec-ext (*-raise-hom _ _)) ‚ü©
      f (map (_*_ x) (raise v)) i
    ‚â°‚ü® hom _ x i ‚ü©
      map (_*_ x) (f (raise v)) i
    ‚àé
    where open ‚â°-Reasoning

  lemma : ‚àÄ (f : Vec (suc m) ‚Üí Vec n)
            (i : Fin n) (j : Fin m) ‚Üí
          f (1‚Çò (suc j)) i ‚â° f (raise (1‚Çò j)) i
  lemma f i x =
    cong (Œª œÜ ‚Üí f œÜ i)
      (vec-ext Œª { zero ‚Üí refl
                 ; (suc n) ‚Üí refl
                 })

  lemma‚ÇÅ : (v : Vec (suc m)) (i : Fin (suc m)) ‚Üí
          ((v zero * (if zero == i then 1# else 0#)) +
            raise (Œª x‚ÇÅ ‚Üí v (suc x‚ÇÅ)) i)
          ‚â° v i
  lemma‚ÇÅ v zero
    rewrite *-identity ≥ (v zero)
      = +-identity ≥ (v zero)
  lemma‚ÇÅ v (suc i)
    rewrite *-zero ≥ (v zero)
      = +-identityÀ° (v (suc i))

  linear-to-matrix
      : {f : Vec m ‚Üí Vec n}
      ‚Üí (lf : LinearFunction f)
      ‚Üí ‚àÄ v
      ‚Üí ‚åä ‚åà lf ‚åâ ‚åã v ‚âó f v
  linear-to-matrix {zero} {n} {f} (add ‚ä¢ hom) v x = begin
    0#                    ‚â°‚ü® sym (*-zeroÀ° _) ‚ü©
    0# * f v x            ‚â°‚ü® sym (hom v 0# x) ‚ü©
    f (Œª i ‚Üí 0# * v i) x  ‚â°‚ü® cong (Œª œÜ ‚Üí f œÜ x) (vec-ext Œª ()) ‚ü©
    f v x                 ‚àé
    where open ‚â°-Reasoning
  linear-to-matrix {suc m} {n} {f} (add ‚ä¢ hom) v x =
    begin
      ‚åä ‚åà add ‚ä¢ hom ‚åâ ‚åã v x
    ‚â°‚ü®‚ü©
      ((Œª i j ‚Üí f (1‚Çò j) i) *‚Çò column v) x zero
    ‚â°‚ü®‚ü©
      sum (Œª i ‚Üí f (1‚Çò i) x * v i)
    ‚â°‚ü®‚ü©
      (f (1‚Çò zero) x * v zero) + sum (Œª i ‚Üí f (1‚Çò (suc i)) x * v (suc i))
    ‚â°‚ü®‚ü©
      (f (1‚Çò zero) x * v zero) + (((Œª i j ‚Üí f (1‚Çò (suc j)) i) *‚Çò column (v ‚àò suc)) x zero)
    ‚â°‚ü®‚ü©
      (f (1‚Çò zero) x * v zero) + ‚åä (Œª i j ‚Üí f (1‚Çò (suc j)) i)‚åã (v ‚àò suc) x
    ‚â°‚ü® cong (Œª œÜ ‚Üí (f (1‚Çò zero) x * v zero) + ‚åä œÜ ‚åã (v ‚àò suc) x) (matrix-ext (lemma f)) ‚ü©
      (f (1‚Çò zero) x * v zero) + ‚åä ‚åà linear-raise (add ‚ä¢ hom) ‚åâ ‚åã (v ‚àò suc) x
    ‚â°‚ü® cong (Œª œÜ ‚Üí (f (1‚Çò zero) x * v zero) + œÜ) (linear-to-matrix (linear-raise (add ‚ä¢ hom)) (v ‚àò suc) x)  ‚ü©
      (f (1‚Çò zero) x * v zero) + f (raise (v ‚àò suc)) x
    ‚â°‚ü® ‚Ä¶algebra‚Ä¶ ‚ü©
      (v zero * f (1‚Çò zero) x) + f (raise (v ‚àò suc)) x
    ‚â°‚ü® sym (cong (_+ f (raise (v ‚àò suc)) x) (hom _ _ _)) ‚ü©
      f (map (_*_ (v zero)) (1‚Çò zero)) x + f (raise (v ‚àò suc)) x
    ‚â°‚ü® sym (add _ _ x) ‚ü©
      f (Œª i ‚Üí (v zero * (if zero == i then 1# else 0#)) + raise (Œª x‚ÇÅ ‚Üí v (suc x‚ÇÅ)) i) x
    ‚â°‚ü® cong (Œª œÜ ‚Üí f œÜ x) (vec-ext (lemma‚ÇÅ v)) ‚ü©
      f v x
    ‚àé
    where open ‚â°-Reasoning

  ‚åä‚åã-linear : (M : Matrix m n) ‚Üí LinearFunction ‚åä M ‚åã
  additive (‚åä‚åã-linear M) v‚ÇÅ v‚ÇÇ i = begin
    ‚åä M ‚åã (zip _+_ v‚ÇÅ v‚ÇÇ) i                      ‚â°‚ü®‚ü©
    sum (Œª j ‚Üí M i j * (v‚ÇÅ j + v‚ÇÇ j))            ‚â°‚ü® ‚Ä¶algebra‚Ä¶ ‚ü©
    sum (Œª j ‚Üí (M i j * v‚ÇÅ j) + (M i j * v‚ÇÇ j))  ‚â°‚ü® sym (+-sum-hom _ _) ‚ü©
    ‚åä M ‚åã v‚ÇÅ i + ‚åä M ‚åã v‚ÇÇ i                      ‚àé
    where open ‚â°-Reasoning
  homogeneity (‚åä‚åã-linear M) v x i = begin
    ‚åä M ‚åã (map (x *_) v) i         ‚â°‚ü®‚ü©
    sum (Œª j ‚Üí M i j * (x * v j))  ‚â°‚ü® ‚Ä¶algebra‚Ä¶ ‚ü©
    sum (Œª j ‚Üí (M i j * v j) * x)  ‚â°‚ü® sym (*-sum-distrib ≥ x) ‚ü©
    sum (Œª j ‚Üí M i j * v j) * x    ‚â°‚ü® *-comm _ x ‚ü©
    x * sum (Œª j ‚Üí M i j * v j)    ‚â°‚ü®‚ü©
    map (x *_) (‚åä M ‚åã v) i         ‚àé
    where open ‚â°-Reasoning

```

subsets


