We would like to give a definition of equality for binary trees such that they
contain the same elements in the same order, but not necessarily that the tree
structure itself is identical. This happens to be a rather interesting example
which generalizes well, and in exploring it we will discover a new construction
over equality.

One flaw with writing a book in the literate style is that sometimes material
must be presented out of order so that the whole thing can compile. And so,
before we look at equality of binary trees, we must first construct a little
combinator. The `def:on` function is given as follows:

```agda
module _ where
  open import Level using (Level; _⊔_)

  private variable
    a b c ℓ : Level
    A : Set a
    B : Set b
    C : Set c

  on : (B → B → C) → (A → B) → A → A → C
  on _∙_ f a₁ a₂ = f a₁ ∙ f a₂
```

We can use `def:on` to conveniently run `f` on both arguments, and then use
`_∙_` to combine both results. It's often used to compare two objects under a
certain perspective. For example, we could check whether two people match, not
by comparing them for equality, but by comparing their fingerprints for
equality. This might be written as `on _≟_ fingerprint`.

You will not be surprised to learn that given a equivalence relation over some
type `B`, we can build an equivalence relation over `A` assuming we are given a
"fingerprinting" function `f : A → B`. In the jargon, this *quotients* `A` by
`f`. First, bring everything into scope as module parameters:

```agda
  open import Relation.Binary
  module Sandbox-Quotient
      {a b ℓ : Level} {B : Set b} {_≈_ : Rel B ℓ}
      {A : Set a} (f : A → B) (≈-equiv : IsEquivalence _≈_) where
```

We can then build the relation quotiented by `f`:

```agda
    _≈/f_ : Rel A ℓ
    _≈/f_ = on _≈_ f
```

and then show that `def:_≈/f_` is an equivalence relation:

```agda
    ≈/f-equiv : IsEquivalence _≈/f_
    IsEquivalence.refl   ≈/f-equiv = IsEquivalence.refl ≈-equiv
    IsEquivalence.sym    ≈/f-equiv = IsEquivalence.sym ≈-equiv
    IsEquivalence.trans  ≈/f-equiv = IsEquivalence.trans ≈-equiv
```

Showing `def:≈/f-equiv` is rather annoying, in that we must copattern match and
then define each as a projection out of `≈-equiv`. This seems as though it's
equivalent to the following definition:

```illegal
    ≈/f-equiv⅋ : IsEquivalence _≈/f_
    ≈/f-equiv = ≈-equiv
```

which it would be, if Agda could figure out the necessary unification.
Unfortunately, it cannot, and thus we must do the hard work of projecting out
each field ourselves. Alas.

You will notice that `module:Sandbox-Quotient` is a very general result, and has
absolutely nothing to do with binary trees. What it really allows us to do is to
transform some type for which we don't have an equivalence relation into another
type in which we do. But not to bury the lede, we can follow through with the
remainder of the binary tree example. First, a new module, and some imports to
get our binary trees from @sec:decidability back into scope:
