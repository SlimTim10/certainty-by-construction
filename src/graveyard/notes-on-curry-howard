# Propositions as Types

```agda
module 4-curry-howard where

open import Data.List
open import Data.Nat
```

Now that we are familiar with our programming language, let's turn our focus
towards more mathematical ideas. When most humans think of mathematics, their
immediate thought is that of numbers. But of course, mathematics is a field
significantly larger than numbers, and we will not deal with numbers in this
section.

But what is mathematics, if not about numbers? I would say it is the process of
clear, logical deduction around precise ideas. Numbers are one such precise
idea, but they are not the only one. In fact, mathematics can be split into two
magisteria: propositions, and proofs of those propositions. Propositions are the
statements you're claiming to be true, while proofs are the evidence you have
that the statements *are* true. In mathematics, unlike science, evidence isn't
just *convincing* --- it's necessarily so. A proof of a proposition has no
wiggle room or space for error; either it is an all-encompassing, argument that
necessitates belief in the premise, or it is not. There are no half measures in
belief in mathematics.

A corollary of this idea is that two mathematicians can have differing opinions
on whether a proposition is true, but once they have a proof, they both must
believe the proposition to be true. Any other result is to not have a proof in
the first place.

There is an analogy to software here --- quite an apt analogy --- that it's easy
to disbelieve a problem can be solved. That is, of course, until someone hands
you the algorithm that solves it. The algorithm is a proof that the problem is
solvable.

It is exactly this analogy that we will exploit for the remainder of this book
in order to show the relationship between mathematics and programming, and
furthermore, to help programmers use the tools they already have to start being
productive in mathematics. But let's make the connection more formal.

To be very explicit, our analogy equates between *mathematical propositions* and
*types.* That is to say, any mathematical proposition has an encoding as a type,
and vice versa. Furthermore, every *proof of a proposition* corresponds to a
*program with that type*. For example, we can say that the following type:

```type
{A : Set} → A → List A
```

corresponds to the proposition "given a value, it is possible to create a list
of the same type." Notice however that this is not a particularly strong claim.
We're merely saying we can build a list, but saying nothing about it. As humans
we might imagine such a list would have length one, and contain the given
element, as in `f1`:

```agda
f1 : {A : Set} → A → List A
f1 a = a ∷ []
```

Because `f1` has type the given type, `f1` is thus a proof that we can indeed
construct a list given a value. However, `f1` is not the only proof of such a
claim. Indeed, while `f1` feels, in some sense, "natural," there are degenerate
programs with the same type. For example, the program which ignores its argument
and always gives back the empty list is a perfectly fine proof:

```agda
f2 : {A : Set} → A → List A
f2 a = []
```

Or perhaps, we could build a list of length five:

```agda
f3 : {A : Set} → A → List A
f3 a = a ∷ a ∷ a ∷ a ∷ a ∷ []
```

It doesn't really matter. There are in fact, infinitely many proofs that we can
construct a list given an argument of the same type --- one for every possible
length of the list.

Because most programming languages have shoddy type systems, it's difficult to
state any mathematically interesting ideas in them. But this is not so in Agda.
In Agda, our limitation is not in the type system, but in our ability to
transform thoughts into types. As we will see, as our agility manipulating types
improves, so too will our ability to grapple with the mathematical ideas.

