### Navigating the Agda Standard Library

Much more so than any other programming language I have ever encountered, Agda
code does not lend itself to being read outside of a code editor. The irony of
this statement in a book presenting Agda code is not lost on the author, but he
will do his best to keep the cognitive load to a minimum. The motivated reader
is highly encouraged to follow along in their text editor.

Inside the editor, your best friend is [GotoDefinition](AgdaCmd), which unlike
many compiled languages, will take you to definitions in any package you have
installed, not just those in the same package you're currently working on.
[GotoDefinition](AgdaCmd) is *necessary* for getting any real work done,
especially in the beginning of your Agda experience when you don't have the
standard library's idioms paged into your head.

The standard library itself is laid out hierarchically, into a few main
categories, with relatively consistent structure. As we are just getting
started, we will limit ourselves to the following top-levels of the module
hierarchy:

- `Data.*`
- `Function`
- `Relation.Binary.*`

The `Data` hierarchy contains all the data types you'll ever need, things like
numbers, booleans, strings, lists, optional values, tuples, trees, that sort of
thing. In particular, we will use (in descending order of relative queerness):

- `Data.Nat` --- natural numbers
- `Data.Bool` --- booleans
- `Data.Product` --- tuples
- `Data.Fin` --- bounded numbers
- `Data.List` --- lists
- `Data.Vec` --- lists with an exact size
- `Data.Unit` --- the type with only one value
- `Data.Sum` --- either/or types
- `Data.Empty` --- the type with no values

Each of these modules contains the core data types and their most usual
operations. This book, and Agda as well, is primarily about *proving things,*
and to that extent, Agda already comes with a great deal of proofs. This work
exists inside the `.Properties` sub-module of each of the above. That is, if
you're looking for a proof about lists, you would do well to look inside of
`Data.List.Properties`. Don't forget to use [GotoDefinition](AgdaCmd) to explore
around when you get there.

The `Function` module contains a lot of the common machinery you'd expect from a
functional programming language, things like the `id`entity function, the
`const`ant function, and function composition (via `_âˆ˜_`.) If this means nothing
to you yet, don't fret, we'll get there. Otherwise, this is the place to look if
you're unsure of where to find any particular function combinator.

Finally, we come to the `Relation.Binary` hierarchy, which contains tools for
*proving* equality (rather than *testing for equality* like most languages do),
as well as discussing different sorts of equality. As a beginner, the most
important module in this hierarchy is `Relation.Binary.PropositionalEquality`
which has everything we'll need to begin thinking about proofs in chapter
@sec:proofs.

