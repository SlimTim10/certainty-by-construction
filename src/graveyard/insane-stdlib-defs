## Normalization

Unfortunately, huge swathes of the standard library are completely
incomprehensible. Worse, it seems like someone must be playing an elaborate joke
on us. Something you'll run across sooner than later is `_Preserves_⟶_`, which
states that some function preserves equality, for example. The details are not
important right now. We can look at the definition of `_Preserves_⟶_` hoping to
gain some insight, but all we are given is this:

```wtf
_Preserves_⟶_ : (A → B) → Rel A ℓ₁ → Rel B ℓ₂ → Set _
f Preserves P ⟶ Q = P =[ f ]⇒ Q
```

Clearly the definition here depends on `_=[_]⇒_`, so we can follow its
definition via [GotoDefinition](AgdaCmd). Unfortunately, this doesn't really
clarify anything:

```wtf
_=[_]⇒_ : Rel A ℓ₁ → (A → B) → Rel B ℓ₂ → Set _
P =[ f ]⇒ Q = P ⇒ (Q on f)
```

Where we once had one puzzle, now we have two: `_⇒_` and `_on_`. Let's proceed
cautiously:

```wtf
_⇒_ : REL A B ℓ₁ → REL A B ℓ₂ → Set _
P ⇒ Q = ∀ {x y} → P x y → Q x y
```

Thankfully the buck stops at `_⇒_`, cashing out into merely being the type of a
function applying two variables pairwise. Again, the purpose here and now is not
necessarily to understand this code, merely to ward off the eventual terror and
despair one might feel if discovering this for themselves. We look into the
pleasantly named `_on_` function, and this is when things begin to really go
wrong:


```wtf
_on_ : (B → B → C) → (A → B) → (A → A → C)
_*_ on f = f -⟨ _*_ ⟩- f
```

Uh oh. Now we need to investigate `_-⟨_⟩-_`? Surely we must be getting close to
the end. One more [GotoDefinition](AgdaCmd), and, oh, god no:

```wtf
_-⟨_⟩-_ : (A → C) → (C → D → E) → (B → D) → (A → B → E)
f -⟨ _*_ ⟩- g = f -⟨ const ∣ -⟪ _*_ ⟫- ∣ constᵣ ⟩- g
```

Surely someone must be pulling our leg here. What in tarnation is all of this
syntax? The unfortunate truth is that this is all library defined, and that Agda
is flexible enough to allow it. We can continue following definitions, but at
this point, personally, my eyes have glazed over and there is no possible way
I'm going to be able to reconstitute all of these definitions back up to
`_Preserves_⟶_` to answer my original question. Just to take the visual gag a
little further, let's look at a few more functions in this call stack:

```wtf
_-⟨_∣ : (A → C) → (C → B → D) → (A → B → D)
f -⟨ _*_ ∣ = f ∘₂ const -⟪ _*_ ∣

_-⟪_∣ : (A → B → C) → (C → B → D) → (A → B → D)
f -⟪ _*_ ∣ = f -⟪ _*_ ⟫- constᵣ

_-⟪_⟫-_ : (A → B → C) → (C → D → E) → (A → B → D) → (A → B → E)
f -⟪ _*_ ⟫- g = λ x y → f x y * g x y
```

You can't make this stuff up. I'm not sure how these definitions got here, but I
do know this is someone who has gone mad with power.

So, playing the [GotoDefinition](AgdaCmd) game clearly hasn't worked for us. Is
there something else we can try to get an understanding of `_Preserves_⟶_`?
Indeed there is --- the [Normalise](AgdaCmd) command, which asks Agda to
evaluate an expression as far as possible. After running [Normalise](AgdaCmd),
we are prompted for what we'd like to evaluate, and we can simply enter
`_Preserves_⟶_`. Our efforts are immediately rewarded with a response from Agda:

```repl
λ f P Q → {x y : z} → P x y → Q (f x) (f y)
```

What's happened here is that we've asked Agda to automate the reasoning chain of
playing [GotoDefinition](AgdaCmd) and attempting to reconstitute an
understanding of the insane choices made in the standard library. While we might
not yet understand Agda's response, we will in a few chapters.

The takeaway here is Agda is extremely good at chasing definitions; feel free to
ask it for help whenever you're feeling overwhelmed.

