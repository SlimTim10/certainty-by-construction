## Agda in a Nutshell

Agda is a pure, dependently-typed functional programming language. *Pure* means
that the language, for the most part, doesn't have any side-effects. That means,
modulo a few stipulations, Agda is unable to talk to the filesystem, make API
calls, check the time, print to stdout, or modify any variables. This is a
severe set of limitations, and probably is unlike any other programming language
you have ever used. The things you *can't* do in Agda consist of most of the
things anyone considers programming to be. And so in what way can we justify
calling Agda a programming language, and what sorts of programs can we write in
it?

In my opinion, Agda's strength is the power of its type system. You might have
heard the adage "if it compiles, it works" which is more true in Agda than in
any other programming language. Most of our interactions with Agda are not for
the purpose of writing programs, but instead, for having a conversation with its
typechecker. Agda lets us express extremely precise types, things like
"everything on the left side of this binary search tree is smaller than the
root." And once you've phrased that as a type, your program implementing
insertion into a binary search tree is *required to prove* that it maintains the
invariant. By virtue of having extremely powerful types, the burden falls upon
us to write extremely correct software, because, for likely the first in our
programming careers, we've had the ability to specify *what correctness means.*

As you know, the hard part about programming is the solving of the problem, not
the finger wiggling necessary to turn it into a program. Agda is a tool for
approaching the first half here: solving and understanding the problem in its
entirety. The odd consequence here is that our resulting programs have no choice
but to be right. We don't need to run them to verify we get the expected output,
because we have proven it in full generality.

After writing Agda daily for over a year, I still haven't felt the need to run
any of my programs. In fact, I don't even know how if I wanted to. The point is
to solidify our understanding and prove it correct. If we still want a
computable artifact, we are free to transpile Agda into some other language, or
rewrite the solution elsewhere now that the hard part is complete.
