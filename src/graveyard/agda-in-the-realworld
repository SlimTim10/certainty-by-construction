Aside from being pure, Agda is also a *functional* programming language, which
is opposed to procedural languages like C++, Python and Ruby, as well as opposed
to object-oriented languages like C# and Java. Functional programs look more
like a series of math equations than they do "recipes." Functional programs have
more of an emphasis on *what things are* rather than *how they compute.* To
illustrate, compare the definition of the factorial in C++:

```cpp
uint64_t factorial(uint64_t n) {
  int64_t result = 1;
  for (uint16_t i = 1; i <= n; i++) {
    result = result * i;
  }
  return result;
}
```

The C++ program is marked by explicit computation; we need to create an
accumulator variable, and then loop through every number, multiplying the
accumulator against the new index, and finally output the result.

Compare this to the same program in Agda:

```agda
factorial : ℕ → ℕ
factorial 0 = 1
factorial (1+ n) = (1+ n) * factorial n
```

in which we state a base case for what to do when the number is 0, and an
induction case for what to do otherwise. The Agda definition closely follows the
mathematical definition of the factorial, and lets us focus more on "what it is
we're talking about" rather than "how does the computer accomplish the task."

Is Agda's implementation of the factorial efficient? In some sense, this is a
meaningless question, because we do not intend to ever *run* the resulting
program. Our definitions are chosen for clarity of thought and reasoning, not
for the computer's sake. Computers are tools to do tedious work on our behalf;
it is simply ass-backwards to do tedious reasoning on behalf of the computer.

Of course, this can at odds with extracting efficient programs should that
desire ever arise. We usually solve this issue in two steps. First, solve the
problem at hand with simple reasoning techniques, and verify the solution is
correct. Second, find a computationally efficient means of tackling the same
problem, and give a proof that it is equivalent to the first way. This allows us
to separate our understanding of how to solve problems from our ability to
subsequently speed them up. But worrying about optimization too early in the
process often gets in the way of finding good solutions.

Functional programs are distinguished from other varieties of programs by being
entirely expressions, never statements. That is, we are syntactically unable to
write "recipe-style" programs of the form "do this, then do that, then do the
other thing." Our only means of expressing programs is as one big expression,
which means that everything is a value, and as a result, we can abstract over
significantly more parts of our program.

