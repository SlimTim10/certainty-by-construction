Because Agda is pure, it cannot have any side effects, so nothing will go wrong
if we define `if_then_else_`:

```agda
if_then_else_ : {ℓ : Level} {A : Set ℓ} → Bool → A → A → A
if true  then t else f = t
if false then t else f = f
```

Here we see quite a few things happening at once. The first is that we can
define the `if..then..else` syntax for ourselves that is usually wired directly
in to most languages. Agda has extremely flexible syntax, allowing us to build
new syntactic constructs using underscores to mark holes. The second thing to
notice is that on both the `then` and `else` branches we fully compute what
happens. But because of Agda's purity, it's impossible to observe the fact that
`if_then_else_` isn't pruning the branch left untaken.

This is a very freeing thought. Liberate your mind from the confines of
procedural programming!

Of course, because this fact is unobservable, we also have no proof that Agda
*isn't* pruning the branch left untaken. It's a non-question, because the
question presupposes a computational model that isn't on the table. The
semantics of Agda give us no means of differentiating whether or not this

The major appeal of pure, functional programming languages is their *referential
transparency.* That is to say, we are free to replace the left-hand side of an
equation with the right-hand side whenever we please, and this is the way by
which computation happens. It means we can fully understand a program simply by
inlining definitions. There is no variable state that we need to mentally track
in order to determine which branch happens. There is no complicated line of
reasoning we need to follow about what happens if the program gets run on a
Tuesday. These are concepts we can't even speak about in Agda, and therefore are
not required to consider.

In this sense, Agda is extremely limited, but that's a feature, not a bug.
Because Agda is so constrained in its functionality, we can say a lot more about
what it does do, since the possibility space is smaller.

Best of all, you might be surprised that Agda is still (effectively) Turing
complete. Anything you can do in any other programming language you can do in
Agda. These limitations might seem severe, but they are not fundamental
problems. They are merely a different way of approaching problems, and one which
we will see is extremely fruitful.

