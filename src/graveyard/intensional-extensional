## Intentional vs Extensional Equality

We will begin our exploration into equality with the example of functions. When
are two functions equal? The answer is not very cut and dry. This is a hard
problem. Consider functions `def:ex₁`, `def:ex₂` and `def:ex₃`:

```agda
module Sandbox-IntensionalExtensional where
  open import Data.Nat
    using (ℕ; _+_;  _*_)
  open ℕ

  ex₁ : ℕ → ℕ
  ex₁ x = x + 2

  ex₂ : ℕ → ℕ
  ex₂ x = 2 * x

  ex₃ : ℕ → ℕ
  ex₃ x = suc (suc x)
```

Clearly functions `def:ex₁` and `def:ex₂` are *not* equal. But the answer is less
clear as to whether `def:ex₁` and `def:ex₃` are. The two functions are syntactically
entirely different, but compute the same output given the same input. If you
were to draw the plots of these two functions, they'd look identical.

But this isn't necessarily the whole story; are bubble sort and merge sort
the same function? They both return the same outputs given the same inputs,
however, they do so in entirely different ways, and with entirely different
computational behaviors. What a mess we find ourselves in.

Many programming languages sidestep the problem by comparing functions by their
pointer equality. In these cases, two functions are the same if they occur at
the same place in memory. But this is unsatisfying on many levels. First and
foremost, it is an abstraction leak. Functions are mathematical ideas,
completely separate from the hardware they run on. There exist models of
computation that don't have memory, and thus such a decision allows you to
deduce properties of the hardware you're running on---which ought to be a
no-no. Mathematics doesn't run on any hardware; it just *is.* Equally abhorrent
in pointer equality of functions is that it means two identical, syntactically
byte-for-byte source identical functions might not compare equal, due to
unpredictable quirks of how the runtime has decided to lay out memory. This
means that a program which might work today could fail tomorrow based only on a
differing mood of the runtime. There are many ways to describe this behavior,
but neither "sane" nor "mathematical" nor even "good programming practice" are
one.

The solution to this problem is to split equality of function types into two
camps. The mathematicians take a stand and say that yes, bubble sort and merge
sort *are* the same function. The computer scientists argue that no, they are
not. In the first world, we care only that the functions map equal inputs to
equal outputs. In the latter, we require the two functions to be defined in
exactly the same way. These two approaches to equality are known as
*extensional* and *intensional* equality, respectively.

Intensionality continues to be a challenge to define. Do variable names matter?
What about no-ops? The entire question is a quagmire, and we will not delve
deeper into this idea here.

Instead, we will worry only about extensional equality. Two functions are thus
equal if they map inputs to equal outputs. That is to say, given two functions
`f` and `g`, we'd like the following property to hold:

```agda
  open import Relation.Binary.PropositionalEquality hiding (_≗_)
  open import Relation.Binary using (Rel)

  _≗_
      : {a b : Level} {A : Set a} {B : A → Set b}  -- ! 1
      → Rel ((x : A) → B x) _ -- ! 2
  _≗_ f g = ∀ x → f x ≡ g x
```

The type here is rather involved, where we have made `B` a type dependent on `A`
at [1](Ann), and then made both `f` and `g` pass their argument to `B` for their
output at [2](Ann). A more intuitive type for `def:_≗_` is:

```type
_≗_ : {A B : Set} → Rel (A → B) _
```

but the extra generality means we can use `def:_≗_` with indexed types and
dependent functions as well. This doesn't matter most of the time, but will lead
to obscure problems if you are not mindful of it.

Given the definition of `def:_≗_`, we can show that `def:ex₁` and `def:ex₃` are
indeed extensionally equal:

```agda
  open import Data.Nat.Properties
    using (+-comm)

  ex₁≗ex₃ : ex₁ ≗ ex₃
  ex₁≗ex₃ zero = refl
  ex₁≗ex₃ (suc x) = cong suc (+-comm x 2)
```

The curious reader might wonder whether `def:_≗_` forms a preorder or an
equivalence relation. In fact it does, given simply by fanning out the argument
to both functions and then using the underling equivalence on `type:_≡_`. Once
you know the trick, it's not very difficult to show on paper, but doing it in
Agda requires jumping through a couple of hoops.

We'd like to bind `A` and `B` once and for all as implicit variables, and then
show that `def:_≗_` is `type:Reflexive`, `type:Symmetric` and `type:Transitive`.
Unfortunately, `def:_≗_` has too many implicit variables for Agda to figure out
the types involved on its own. Thus in order to avoid unsolved metas, we must
explicitly give some types to `type:Reflexive` et al.,

Due to a technical quirk with how Agda handles implicits defined via
`keyword:variable`, it's rather more verbose to do our usual thing here. So
rather than defining our implicits in a `keyword:variable` block, we will
instead construct a private module and add the implicits as parameters to that.
The exact details aren't of importance here, but the dedicated student is
encouraged to repeat this section on their own using a `keyword:variable` block
and see for themself what goes wrong.

```agda
  module _ {a b : Level} {A : Set a} {B : A → Set b} where
```

With our implicits now in scope, we can define an alias for dependent functions:

```agda
    private
      Fn : Set _
      Fn = (x : A) → B x
```

and now show that `def:_≗_` is `type:Reflexive` when its `A` parameter is
instantiated at `type:Fn`:

```agda
    open import Relation.Binary
      using (Reflexive; Symmetric; Transitive; IsEquivalence)

    ≗-refl : Reflexive {A = Fn} _≗_
    ≗-refl x = refl
```

With the `type:Fn` trick sorted out, it's not very hard to define symmetry or
transitivity---just apply the extensional equality, and perform the underlying
operation on the result:

```agda
    ≗-sym : Symmetric {A = Fn} _≗_
    ≗-sym f≗g a = sym (f≗g a)

    ≗-trans : Transitive {A = Fn} _≗_
    ≗-trans f≗g g≗h a = trans (f≗g a) (g≗h a)
```

Therefore `def:_≗_` is an equivalence relation:

```agda
    ≗-equiv : IsEquivalence {A = Fn} _≗_
    IsEquivalence.refl   ≗-equiv = ≗-refl
    IsEquivalence.sym    ≗-equiv = ≗-sym
    IsEquivalence.trans  ≗-equiv = ≗-trans
```


## Function Extensionality

If you are working in more of a mathematical domain (as opposed to a
computational one), you might want to postulate *function extensionality*: the
notion that extensionally equal functions are in fact *propositionally equal.*
As we have seen, this doesn't make sense when computation is your main goal, but
if you are simply modeling the world, it's an extremely convenient thing to have
around. We can postulate `def:fun-ext` as follows:

```agda
  postulate
    fun-ext
        : {a b : Level} {A : Set a} {B : A → Set b}
        → {f g : (x : A) → B x}
        → f ≗ g → f ≡ g
```

Function extensionality doesn't exist in the standard library; while Agda is
compatible with it, it can be neither proven nor disproven in Agda, and
therefore you must be the one to decide whether or not it holds.

Given `def:fun-ext`, we can trivially lift our proof `def:ex₁≗ex₃` into a proof
that the two functions are propositionally equal:

```agda
  ex₁≡ex₃ : ex₁ ≡ ex₃
  ex₁≡ex₃ = fun-ext ex₁≗ex₃
```

Of course, you don't need to postulate `def:fun-ext`; you can always work
directly with extensional equality itself, instantiating it to get whatever
proof of equality you actually need. But the ergonomics around `def:fun-ext` can
dramatically improve the story, if you're willing to give up on computability
for it.
