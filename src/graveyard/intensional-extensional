# Equality

```agda
module 5-equality where

open import Data.Nat

postulate
  todo : {A : Set} → A

module Examples where
  open import Relation.Binary.PropositionalEquality

  postulate
    IO : Set → Set
    ⊤ : Set
```


## Intentional vs Extensional Equality

Based on the above examples, equality might seem like the clearest thing in the
world. This is not entirely the case, however. For numbers and booleans and
strings, the story is cut and dry, but difficulties arise when we begin to think
about more exotic types. In particular, let's take some time to discuss when two
functions are equal.

When *are* two functions equal? This is a hard problem. Consider functions `f`,
`g` and `h`:

```agda
f : ℕ → ℕ
f x = x + 2

g : ℕ → ℕ
g x = 2 * x

h : ℕ → ℕ
h x = suc (suc x)
```

Clearly functions `f` and `g` are *not* equal. But the answer is less clear as
to whether `f` and `h` are. The two functions are syntactically entirely
different, but compute the same output given the same input. If you were to draw
the plots of these two functions, they'd look identical.

But this isn't necessarily the whole story; are `bubblesort` and `mergesort`
equal functions? They both return the same outputs given the same inputs,
however, they do so in entirely different ways, and with entirely different
runtime asymptotic complexities!

Yikes. What a mess we find ourselves in.

Many programming languages sidestep the problem by comparing functions by their
pointer equality. In these cases, two functions are the same if they occur at
the same place in memory. But this is unsatisfying on many levels. First and
foremost, it is an abstraction leak. Functions are mathematical ideas,
completely separate from the hardware they run on. There exist models of
computation that don't have memory, and thus such a decision allows you to
deduce properties of the hardware you're running on --- which ought to be a
no-no. Mathematics doesn't run on any hardware; it just *is.* Equally abhorrent
in pointer equality of functions is that it means two identical, syntactically
byte-for-byte source identical functions might not compare equal, due to
unpredictable quirks of how the runtime has decided to lay out memory. This
means that a program which might work today could fail tomorrow based only on a
differing mood of the runtime. There are many ways to describe this behavior,
but neither "sane" nor "mathematical" nor even "good programming practice" are
one.

The mathematical solution to this problem is to split equality of function types
into two camps. There is a world in which `bubblesort` and `mergesort` *are* the
same function, and a world in which they are not. In the first world, we care
only that the functions map equal inputs to equal outputs. In the latter, we
require the two functions to be defined in exactly the same way. These two
approaches to equality are known as *extensional* and *intensional* equality,
respectively.

Intensionality continues to be a challenge to define. Do variable names matter?
What about no-ops? The entire thing is a boondoggle, and we will not delve
deeper into this idea.

Instead, we will worry only about extensional equality. Two functions are thus
equal if they map inputs to equal outputs. That is to say, given two functions
`f` and `g`, we'd like the following property to hold:

```agda
open import Relation.Binary.PropositionalEquality hiding (_≗_)

_≗_ : {A B : Set} → (A → B) → (A → B) → Set
_≗_ {A} f g = (a : A) → f a ≡ g a
```

We can read this as `f ≗ g` is a *type synonym* for a function that transforms
`a : A`s into proofs of equality between `f a` and `g a`.

