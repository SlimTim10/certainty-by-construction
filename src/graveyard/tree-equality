## Equality of Binary Trees

```agda
module Example-BinaryTrees where
  import 4-decidability
  open 4-decidability.BinaryTrees
```

We now need a fingerprinting function to quotient our trees by. Recall that we'd
like to throw away the nesting structure of the tree, keeping only the contents
and the order. We could do that by transforming our binary trees into *normal
form*---finding some invariant that we hold true, such as ensuring every
`ctor:branch` has `ctor:empty` as its left tree. Making such a transformation
would ensure that our non-propositional notion of equality could be show via
propositional equality proper. This is the right idea, but sounds hard to get
right. Instead, we note that any binary tree with subtrees in only one direction
is not *binary* whatsoever, and reduces to a linked list.

It brings me distinct pleasure to have made it this far into a functional
programming book without having talked about linked lists. But the time is now.
Rather than dwelling on them, we assume the reader now has enough technical
proficiency in Agda (and familiarity with computing) to understand the following
presentation of linked lists without commentary. We first define the type
itself:

```agda
  data List (A : Set) : Set where
    []   : List A
    _∷_  : A → List A → List A
  infixr 4 _∷_
```

Next, we give concatenation for lists:

```agda
  _++_ : {A : Set} → List A → List A → List A
  [] ++ ys = ys
  (x ∷ xs) ++ ys = x ∷ xs ++ ys

  infixr 4 _++_
```

We are now able to fingerprint our binary trees by giving a left-to-right
traversal, collecting the results into a linked list:

```agda
  contents : {A : Set} → BinTree A → List A
  contents empty = []
  contents (branch l a r) = contents l ++ a ∷ contents r
```

-- TODO(sandy): fix the original definition of `≡-equiv` so we can just import
-- it here instead of postulating it

```agda
  open import Relation.Binary using (Rel; IsEquivalence)
  open import Relation.Binary.PropositionalEquality
    using (_≡_; refl; _≢_)

  postulate
    ≡-equiv : {A : Set} → IsEquivalence {A = A} _≡_
```

We can now demonstrate our quotienting machinery by building two example trees:

```agda
  module _ where
    open import Data.Nat

    ex₁ : BinTree ℕ
    ex₁ = branch (leaf 1) 2 (leaf 3)

    ex₂ : BinTree ℕ
    ex₂ = branch (branch (leaf 1) 2 empty) 3 empty
```

It's clear that `def:ex₁` and `def:ex₂` are not *propositionally* equal, as
illustrated thusly:

```agda
    ex₁≠ex₂ : ex₁ ≢ ex₂
    ex₁≠ex₂ = λ ()
```

but the two do have the same elements in the same order, and thus we can show
they are equal under quotienting by `def:contents`:

```agda
    open Sandbox-Quotient (contents {ℕ}) ≡-equiv
      renaming (_≈/f_ to _≈ᴮ_)

    ex₁≈ᴮex₂ : ex₁ ≈ᴮ ex₂
    ex₁≈ᴮex₂ = refl
```

Et voila! A thing of rare beauty.

