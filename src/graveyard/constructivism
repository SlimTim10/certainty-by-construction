# Constructivism and Computation

It is worth noting that the mathematics we will be doing in this book are not
the "whole story" of mathematics. You see, there are two big camps in the
mathematics worlds: the *classicists* and the *constructivists.* Much like
many religious sects, these two groups have much more in common than they have
distinct. In fact, the only distinction between these two groups of
truth-seekers is their opinion on the nature of falsities.

The classicists believe all mathematical statements are divided into the ones
which are *true* and the ones which are *false.* There is no middle ground, and
thus the ones which are not true must certainly be false, and vice versa. It is
very probable that you, gentle reader, fall into this camp, likely without
knowing it. Most of the world does.

Contrasting with the classicists are the constructivists, who trust their nose
more than they trust logical arguments. Constructivists aren't happy knowing
something merely *doesn't not exist;* they'd like to see that thing with their
own eyes.

In general, there are two ways to mathematically show something exists. The
first way is to just build the thing, in sense "proof by doing." The other is to
show that a world without the thing would be meaningless, and thus show its
existence --- in some sense --- by sheer force of will, because we really
*don't* want to believe our world is meaningless.

To illustrate this difference, suppose we'd like to prove the existence of a
number that is divisible by 2, and 5. Under a classical worldview, a perfectly
acceptable (although silly) proof would go something like this:

-- TODO(sandy): gross

* Suppose there does not exist a number $n$ that is divisible by 2 and 5.
* The factorial function $m!$ has divisors for every $x \le m$.
* $2 \le 5$
* The factorial function is monotonically increasing.
* Therefore, there exists some number $k$ such that $k!$ has divisors 2 and 5.
* But we said there is no such number. This is a contradiction.
* Therefore there does exist a number $n$ that is divisible by 2 and 5.

The constructivists instead, are required to just give you some multiple of 10.

This perspective suggests that the difference between the two camps is one more
of philosophy than it is necessarily of technique. In fact, the classical proof
above gives a hint as to what this philosophical difference really is. The
classicists view contradiction as anathema, and thus that anything which leads
to it must be false. The constructivists, on the other hand, *define refutation
of a claim* as being a proof that it would result in contradiction.

Symbolically, we write the refutation of a proposition `P` as `¬ P`, and the
entire disagreement descends into a question of whether the following function
should exist:

```notagda
¬-elim : ¬ (¬ P) → P
```

that is, do two negations cancel one another? In essence, this really boils down
to a question of "what type does `P` have?" The classicists say `P : Bool`,
while the constructivists say `P : Set`. Under `P : Bool`, it's clear that `¬ =
not`, and thus, that `¬-elim` is inhabited.

However, this is less clearly true under the constructivist perspective that `P
: Set`. Instead, we begin by defining the `Set` of falsity. Since both camps
agree that there should never be a proof of false, this `Set` is defined by
having no inhabitants:

```agda
{-# OPTIONS --allow-unsolved-metas #-}

module constructivism where

module introduction where
  data ⊥ : Set where
    -- intentionally left empty
```

Mathematicians hate the idea of having a proof of false, because of the
principle of *reductio ad absurdum* --- that is, from false, you can prove
anything. We can show this in Agda:

```agda
  private variable
    P : Set

  ⊥-elim : ⊥ → P
  ⊥-elim ()
```

This funny `()` pattern is Agda's acknowledgment that this function is vacuously
true. That is, it's a bit of a bluff: `⊥-elim` can return any `A` you want
because you can't actually call it in the first place ---- there are no `⊥`s
around to use as an argument to call the thing!

And this is the necessary trick the constructivists use to encode a false
statement; from it, you could conclude anything, including `⊥` which we have
intentionally constructed as something un-concludable. That is, we can define
the refutation of `P` as a function that, given a `P`, would result in `⊥`:

```agda
  ¬ : Set → Set
  ¬ P = P → ⊥
```

We can use `¬` to construct more traditional sorts of "negative propositions",
like the fact that two things are *not* equal:

```agda
  open import Relation.Binary.PropositionalEquality using (_≡_)

  _≢_ : P → P → Set
  x ≢ y = ¬ (x ≡ y)
```

Returning to the idea of `¬-elim : {A : Set} → ¬ (¬ A) → A`, it's clear that
this simply isn't true given our encoding of `¬`. We would like to produce an
`A`, but all we have is a function `(A → ⊥) → ⊥`. There's nowhere to get an `A`
from, but maybe we could cheat and try `⊥-elim` on the result of our function.

Following this line of thought through, we can get as far as the following:

```agda
  ¬-elim : ¬ (¬ P) → P
  ¬-elim ¬p→⊥ = ⊥-elim (¬p→⊥ (λ p → {! !}))
```

where we now have `a : A` in scope, but simply have no way to exfiltrate it.
Alas.

You might have heard of the *law of the excluded middle,* or LEM for short,
which is exactly the classical claim that any proposition is either true or it
is false. That is, `lem : {P : Set} → P ⊎ ¬ P`. Traditionally, it is the
existence of LEM which differentiates classical from constructive mathematics,
so why are we talking about `¬-elim` instead? As it happens, the LEM is
equivalent to `¬-elim`, which we can prove by implementing one in terms of the
other.

Assuming we have `¬-elim`, we can use it to provide the law of excluded middle,
as per `¬-elim→lem`. The trick is to use `¬-elim` to get into scope a proof that
the LEM doesn't hold, with the intention to derive a contradiction from this
fact:

```agda
  open import Data.Sum

  ¬-elim→lem : P ⊎ ¬ P
  ¬-elim→lem = ¬-elim λ ¬lem →
    ¬lem ?
```

In order to show the contradiction, we must fill the hole with a `P ⊎ ¬ P`. But
that was our original goal, which you might think means we haven't accomplished
anything. But in fact, we have. We've gained the ability to bluff. Now, we can
say "no, `P` certainly isn't true:"

```agda
  ¬-elim→lem⅋ : P ⊎ ¬ P
  ¬-elim→lem⅋ = ¬-elim λ ¬lem →
    ¬lem (inj₂ λ p → ?)
```

In order to show `P` isn't so, we must be able to turn a proof of `P` into `⊥`,
which we can do by reneging on our early promise that `P` wasn't true, since we
now have evidence that it is!

```agda
  ¬-elim→lem⅋⅋ : P ⊎ ¬ P
  ¬-elim→lem⅋⅋ = ¬-elim λ ¬lem →
    ¬lem (inj₂ λ p →
      ¬lem (inj₁ p))
```

What a weaselly sort of way to something --- pretend it isn't, and change your
mind if someone calls your bluff. Nevertheless, the typechecker is happy, and
therefore, we are too.

Recall that Agda is a programming language, and thus that there must be some
sort of computational intepretation of the programs we can write in it. The
computational interpretation of the LEM is to say "no," but if anyone ever
refutes that, you just rewind back to where you said "no" and say "yes" instead,
using your new evidence. In this light, `¬-elim` captures the current
continuation of the remainder of the program, and calling that function will
rewind all of your progress, jumping back to whatever instruction was next when
you called `¬-elim`.

The harm here is the existence of this non-determinism. You can go your whole
life, proving things that transitively depend on `¬ P`. But then, two hundred
years later, it turns out `P` was true all along, which means that none of your
life's work still holds! Better to be safe, and admit our ignorance that we
simply don't know which of `P` or `¬ P` is true, rather than pretending and
hoping we got it right.

Returning to the problem at hand, it's thankfully much simplier to go the other
direction, from the LEM to `¬`-elimination. We just ask which one is true. If
it's `P`, then we're already done. Otherwise, we can use `¬ P` to get a `⊥` and
then `⊥`-eliminate it away.

```agda
  lem→¬-elim : ¬ (¬ P) → P
  lem→¬-elim ¬p→⊥ with ¬-elim→lem
  ... | inj₁ p = p
  ... | inj₂ ¬p = ⊥-elim (¬p→⊥ ¬p)
```

For the remainder of this book, we will ignore the possibility of the existence
of the law of the excluded middle, and by equivalence, the possibility of
`¬-elim`. We will focus our efforts henceforth entirely on constructivist
mathematics, but that is not to say that classical mathematics can't be done in
Agda! You can merely `postulate` the LEM and be on your merry way.

