
# Setoids

```agda
module Chapter6-setoids where

open import Level using (Level)
  renaming (suc to lsuc; _⊔_ to _⊔l_)
```

In this chapter, we will discuss many more notions of equality, many of which
are directly relevant to programming. For example, we might not care if two
file names are exactly equal; merely that they're equal up to case
insensitivity. Or that two binary trees are equal if they contain the same
elements. Propositional equality is capable only of dealing with two objects
which are syntactically equal, but is of absolutely no use to us for these more
common cases. Who knew equality could be such a messy business?





## Setoids

Let's look again at the definition of `module:Sandbox-Quotient`.

```agda
  module Sandbox-Quotient⅋
      {a b ℓ : Level} {B : Set b} {_≈_ : Rel B ℓ}
      {A : Set a} (f : A → B) (≈-equiv : IsEquivalence _≈_) where
```

You'll notice that this is quite a lot of boilerplate required in order to get
everything into scope. We need `b : Level` and `ℓ : Level` around so that we can
properly scope `B : Set b`, in order to scope `_≈_ : Rel B ℓ`, all so that we
can show that `_≈_` is an equivalence relation. In fact, this is such a common
grouping of objects that we often *bundle* them together into a single object
known as a *setoid.* The definition is given thusly:

```agda
  module Sandbox-Setoids where
    record Setoid (c ℓ : Level) : Set (lsuc (c ⊔l ℓ)) where
      field
        Carrier        : Set c
        _≈_            : Rel Carrier ℓ
        isEquivalence  : IsEquivalence _≈_

      open IsEquivalence isEquivalence public
```

By bundling these three fields together, we can more easily pass an equivalence
relationship around. To illustrate this, we can rewrite our module definition of
`module:Sandbox-Quotient⅋₁`:


```agda
  open Sandbox-Setoids

  module Sandbox-Quotient⅋₁
      {a b ℓ : Level} (B-setoid : Setoid b ℓ) {A : Set a}
      (f : A → Setoid.Carrier B-setoid)  -- ! 1
      where
    open Setoid B-setoid renaming (Carrier to B)  -- ! 2
```

The salient change here is that we no longer have `B` in scope; thus we must
reference it via `Setoid.Carrier B-setoid` at [1](Ann), and can bring it back
into scope at [2](Ann) by opening the `B-setoid` record and renaming
`field:Carrier`.

The vast entirety of Agda's standard library is based around setoid
rather than propositional equality. Thankfully, there is a canonical means of
turning propositional equality into setoid equality, given via `def:setoid`,
which merely recognizes the fact that propositional equality is itself a setoid:

```agda
  open import Relation.Binary.PropositionalEquality as PropEq
    using (_≡_)

  open Setoid

  setoid : Set → Setoid _ _
  Carrier (setoid A) = A
  _≈_ (setoid A) = PropEq._≡_
  IsEquivalence.refl   (isEquivalence (setoid A)) = PropEq.refl
  IsEquivalence.sym    (isEquivalence (setoid A)) = PropEq.sym
  IsEquivalence.trans  (isEquivalence (setoid A)) = PropEq.trans
```

However, we will not use our own definition of either `type:Setoid` or
`def:setoid` in the remainder of this book. Due to the prevalence of setoids in
the standard library, we will get significantly more interoperability by
importing the usual definition. But don't worry; it's defined identically to
what we have here.

```agda
open import Relation.Binary
  using (Setoid)
open import Relation.Binary.PropositionalEquality
  using (setoid)
```

Setoids are useful only as an interface for abstracting a notion of equality.
That means, when you're working in a particular domain, like we were in modular
arithmetic, you don't need them. But whenever you'd like to build an abstract,
parameterized structure that enforces laws, you ought to use a setoid to ensure
maximum reusability of your concept.

```agda
open import Relation.Binary
  using (Rel; IsEquivalence)

module Setoid-Examples where
  open import Level using (Level; _⊔_)
  open import Relation.Binary using (Setoid)
  open import Relation.Binary.PropositionalEquality
    using (setoid)
  open Setoid

  module _ where
    open Sandbox-IntensionalExtensional

    ext-setoid
        : {ℓa ℓb : Level}
        → (A : Set ℓa)
        → (B : A → Set ℓb)
        → Setoid _ _
    Setoid.Carrier        (ext-setoid A B) = (a : A) → B a
    Setoid._≈_            (ext-setoid A B) = _≗_
    Setoid.isEquivalence  (ext-setoid A B) = ≗-equiv

  open import Data.Nat using (ℕ)

  module _ {ℓ : Level} (A : Set ℓ) {n : ℕ} where
    open import Data.Vec

    length-setoid : Setoid _ _
    Carrier length-setoid = _
    _≈_ length-setoid = _
    isEquivalence length-setoid = ≈/f-equiv
      where
        open Sandbox-Quotient
            (length {A = A} {n = n})
            (Setoid.isEquivalence (setoid _))

    head-setoid : Setoid _ _
    Carrier head-setoid = _
    _≈_ head-setoid = _
    isEquivalence head-setoid = ≈/f-equiv
      where
        open Sandbox-Quotient
            (head {A = A} {n = n})
            (Setoid.isEquivalence (setoid _))

```

