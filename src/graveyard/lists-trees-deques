# Data and Types

```agda
module Chapter3-types where
```

## Data Structures

Closely related to the natural numbers are (rather surprisingly) a common data
structure: linked lists. The exact nature of this relationship we will not
explore right this instant, but the reader is encouraged to ponder it
themselves. For our purposes, a linked list contains zero or more nodes of the
same type. But which type? Any type you want, so long as you are consistent all
the way through the list.

We can define a linked list as follows, where we add a new `A : Set` parameter
to the type itself, parameterizing us over the type of the contents of the list.

```agda
data List (A : Set) : Set where
  [] : List A
  _∷_ : A → List A → List A

infixr 3 _∷_
```

We use the `[]` constructor to indicate an empty list, while the infix `_∷_`
operation allows us to stick an `A` value in front of an existing list. Thus, we
can make a `List` that enumerates our primary colors:

```agda
all-primary-colors : List PrimaryColor
all-primary-colors = red ∷ green ∷ blue ∷ []
```

Now that we have a flavor of implementing a data structure, let's see what other
data structures we can build. One particularly elegant data structure is the
*binary tree.* There are many variants of binary trees, but ours will keep data
only in the internal nodes.

A binary tree is thus parameterized by its contents:

```agda
data BinTree (A : Set) : Set where
```

and is either an empty tree:


```agda
  empty : BinTree A
```

or is an internal node, with subtrees on the left and right, and a piece of data
between them:

```agda
  branch : BinTree A → A → BinTree A → BinTree A
```

Recall that the last arrow indicates the resulting type, while every one before
the final arrow indicates a parameter. Thus `branch` has three parameters, its
left sub-tree `BinTree A`, data contents `A`, and a right sub-tree `BinTree A`.

Notice that all we are doing here is describing the *shape* of values of a data
structure. We are not implementing any of the interfaces or operations for
working with these structures. As it turns out, getting the shapes right is the
hard part; when those are in place, the operations come mostly "for free." All
of the work has been done in ensuring the necessary invariants hold at the
type-level.

This gives us a new way of thinking about types: they are maintainers of
invariants. For example, binary trees have the invariant that they are either
empty, or have a left and a right sub-tree. We have constrained the creation of
binary trees to always be exactly one of these cases --- you can either build
one out of `empty`, or one out of `branch`. It is impossible (and meaningless)
to construct a `BinTree` that has three immediate sub-trees.


Exercise

:   Give a type corresponding to a stack data structure. Does it remind you of
    anything?


Solution

:   ```agda
data Stack (A : Set) : Set where
  empty : Stack A
  push : A → Stack A → Stack A
    ```

Many programming languages have "the billion dollar mistake" --- a value called
`null` that lives as an extra inhabitant inside of every type. While `null` can
be convenient in some circumstances, primarily in cases of not-yet-initialized,
intentionally-excluded, or no-result, making it omnipresent in all types means
the programmer must be hyper vigilant. No matter how well-reasoned their code
is, there's always the possibility that something which logically must exist
could somehow be set to `null`.

In the type theory, we forbid the omnipresent `null`, while acknowledging that
it has its time and its place: the need to "extend" some other type with a
possible extra value corresponding to nothingness. As such, we can build a
nullable type in the same way that we built our silly `Tribool` earlier: just
extend a different type!

"Nullable" types are better known as `Maybe`, which are parameterized by the
desired "wrapped" type:

```agda
data Maybe (A : Set) : Set where
```

We have two ways of building a `Maybe A`; either you don't have an `A` in the
first place, in which case you have the "null" case:

```agda
  nothing : Maybe A
```

or you do in fact have an `A`, in which case you can build it via `just`:

```agda
  just : A → Maybe A
```

As a result, `nothing` isn't an inhabitant of `Bool`, but it *is* an inhabitant
of `Maybe Bool`. Dually, `true` isn't an inhabitant of `Maybe Bool`, but it has
an equivalent, `just true` which is. By being more rigid about what types things
have, we have completely eliminated an entire family of bugs. In this
formulation, there is no such thing as a forgotten null check; the check is
either impossible to write (in the case of `Bool`), or mandated (in the case of
`Maybe Bool` where it's impossible to be used as a `Bool` until you've proven it
isn't `nothing`.)

<!-- TODO(sandy): awkward transition -->


There is a general rule at play here, which is that if two types "contain the
same data" they should *have the same construction.* Another way of saying that
is *there is only a single way of representing a given piece of data.* This rule
is fast and loose, but it is certainly something to strive for --- especially in
the beginning. You'll notice that if we were to draw a tree on paper, for
example @fig:tree-ex.

---yo{design=code/Dot.hs #fig:tree-ex}
Split "Mika"
  (Split "Foggy"
    (leaf "Brandon")
    (leaf "Gem")
  )
  (Split "Sierra"
    (leaf "Pokey")
    (leaf "Vavilov")
  )
---

we have exactly one way of representing it:

```agda
open import Data.String using (String)

singleton : {A : Set} → A → BinTree A
singleton x = branch empty x empty

tree-ex : BinTree String
tree-ex =
  branch
    (branch
      (singleton "Brandon")
      "Foggy"
      (singleton "Gem"))
    "Mika"
    (branch
      (singleton "Pokey")
      "Sierra"
      (singleton "Vavilov"))
```

With this constraint in mind, it's worth taking some time to describe common
data structures which *do not* correspond to types as we've seen thus far. For
example, consider the double-ended queue (the "D-E-queue"), which we could
potentially encode thusly:

```agda
module Stupid where
  data Dequeue (A : Set) : Set where
    empty : Dequeue A
    at-front : A → Dequeue A → Dequeue A
    at-back  : Dequeue A → A → Dequeue A
```

which seems perfectly reasonable, except that it captures more than just the
contents of the dequeue; it also captures the way in which the dequeue was
*built*. To illustrate, consider the dequeue `[1, 2]` --- it could have built in
any of four ways, and therefore there are four values of type `Dequeue N` which
correspond:

* `at-front 1 (at-front 2 empty)`
* `at-front 1 (at-back 2 empty)`
* `at-back 2 (at-back 1 empty)`
* `at-back 2 (at-front 1 empty)`

Perhaps this information might be useful for tracking some sort of
user-facing, undoable operation, but it is superfluous in the case of *what are
the contents of this dequeue.* Data structures are interested only in the data
they store, and thus any other data they track is necessarily "junk."

A better means of implementing a double-ended queue is instead to ask ourselves
"how can we ensure there is no junk in our data structure?" One way is to lay
out the possible cases, ignoring the usual interface. In this case, a dequeue is
either empty:

```agda
data Dequeue (A : Set) : Set where
  empty : Dequeue A
```

or it contains a single element:

```agda
  one : A → Dequeue A
```

or it contains many elements, with one the front, some in the middle, and one on
the back:

```agda
  many : A → Dequeue A → A → Dequeue A
```

The purpose of the `many` constructor is to ensure the last element is equally
"accessable" as the first element. Contrast this to the linked list, in which we
are required to traverse the entire "spine" of the list in order to get to the
last element --- an operation which necessarily takes $O(n)$ time. Instead, in
`Dequeue`, we have equal opportunity to look at either the front or the back.

You can imagine what a `push-front` operation on our `Dequeue` type would look
like. If the dequeue were already `empty`, it would now contain `one` element:

```agda
push-front : {A : Set} → A → Dequeue A → Dequeue A
push-front a empty = one a
```

Otherwise, if it already had `one` element, it now has `many` with an `empty`
middle:

```agda
push-front a (one x) = many a empty x
```

And finally, if it were already `many`, we can put our new value at the front
and recursively `push-front` the old front value down the middle:

```agda
push-front a (many x d y) = many a (push-front x d) y
```

Compare this to a more traditional, procedural data structure for a dequeue. If
you're thinking about data as *memory,* a dequeue is usually implemented as a
doubly-linked list, where each node has a pointer to its next element and its
previous one. The dequeue itself has pointers to the front and back, and
enqueueing a new element at the front requires creating a new node on the heap,
setting its next pointer to the front of the dequeue, and then setting the front
of the dequeue to the new node! Notice that none of this work is relevant to the
problem; it's merely shunting memory around in a way that happens to work.
Contrasted against our `push-front` function, in which we can see exactly how
the data structure changes, on a case-by-case basis. Neat, and simple.

```agda
open import Data.Product

pop-front : {A : Set} → Dequeue A → Maybe (A × Dequeue A)
pop-front empty = nothing
pop-front (one x) = just (x , empty)
pop-front (many x d y) with pop-front d
... | nothing = just (x , one y)
... | just (x' , d') = just (x , many x' d' y)

```

The truly important takeaway here is that the values of the types should hold
exactly the information we're interested in, nothing more, and nothing else. Of
course, this isn't quite enough; we'd also like to optimize for ease-of-use,
in whatever way is most convenient for our intended application. Of course, we
can always use a (singly) linked list to represent a double-ended queue, but
doing so would privilege one side of the queue unfairly over the other. Clever
type design allows us to instill our desired properties into data *by
construction* --- that is to say, that our invariants must hold, because it is
impossible to build data which doesn't satisfy them.



